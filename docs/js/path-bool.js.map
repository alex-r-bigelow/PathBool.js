{"version":3,"file":"path-bool.js","sources":["../src/intersections/line-segment-AABB.ts","../src/primitives/AABB.ts","../src/QuadTree.ts","../src/intersections/path-cubic-segment-self-intersection.ts","../node_modules/gl-matrix/esm/common.js","../node_modules/gl-matrix/esm/mat2.js","../node_modules/gl-matrix/esm/mat2d.js","../node_modules/gl-matrix/esm/vec2.js","../src/util/math.ts","../src/primitives/Vector.ts","../src/primitives/PathSegment.ts","../src/intersections/line-segment.ts","../src/intersections/path-segment.ts","../src/util/generic.ts","../src/util/iterators.ts","../src/path-boolean.ts","../src/primitives/PathCommand.ts","../src/primitives/Path.ts","../src/path-data.ts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { AABB } from \"../primitives/AABB\";\nimport { Vector } from \"../primitives/Vector\";\n\ntype LineSegment = [Vector, Vector];\n\n// https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm\n\nconst INSIDE = 0;\nconst LEFT = 1;\nconst RIGHT = 1 << 1;\nconst BOTTOM = 1 << 2;\nconst TOP = 1 << 3;\n\nfunction outCode(x: number, y: number, boundingBox: AABB) {\n    let code = INSIDE;\n\n    if (x < boundingBox.left) {\n        code |= LEFT;\n    } else if (x > boundingBox.right) {\n        code |= RIGHT;\n    }\n\n    if (y < boundingBox.top) {\n        code |= BOTTOM;\n    } else if (y > boundingBox.bottom) {\n        code |= TOP;\n    }\n\n    return code;\n}\n\nexport function lineSegmentAABBIntersect(seg: LineSegment, boundingBox: AABB) {\n    let [[x0, y0], [x1, y1]] = seg;\n\n    let outcode0 = outCode(x0, y0, boundingBox);\n    let outcode1 = outCode(x1, y1, boundingBox);\n\n    while (true) {\n        if (!(outcode0 | outcode1)) {\n            // bitwise OR is 0: both points inside window; trivially accept and exit loop\n            return true;\n        } else if (outcode0 & outcode1) {\n            // bitwise AND is not 0: both points share an outside zone (LEFT, RIGHT, TOP,\n            // or BOTTOM), so both must be outside window; exit loop (accept is false)\n            return false;\n        } else {\n            const { top, right, bottom, left } = boundingBox;\n\n            // failed both tests, so calculate the line segment to clip\n            // from an outside point to an intersection with clip edge\n            let x: number, y: number;\n\n            // At least one endpoint is outside the clip rectangle; pick it.\n            const outcodeOut = outcode1 > outcode0 ? outcode1 : outcode0;\n\n            // Now find the intersection point;\n            // use formulas:\n            //   slope = (y1 - y0) / (x1 - x0)\n            //   x = x0 + (1 / slope) * (ym - y0), where ym is ymin or ymax\n            //   y = y0 + slope * (xm - x0), where xm is xmin or xmax\n            // No need to worry about divide-by-zero because, in each case, the\n            // outcode bit being tested guarantees the denominator is non-zero\n\n            if (outcodeOut & TOP) {\n                // point is above the clip window\n                x = x0 + ((x1 - x0) * (bottom - y0)) / (y1 - y0);\n                y = bottom;\n            } else if (outcodeOut & BOTTOM) {\n                // point is below the clip window\n                x = x0 + ((x1 - x0) * (top - y0)) / (y1 - y0);\n                y = top;\n            } else if (outcodeOut & RIGHT) {\n                // point is to the right of clip window\n                y = y0 + ((y1 - y0) * (right - x0)) / (x1 - x0);\n                x = right;\n            } else if (outcodeOut & LEFT) {\n                // point is to the left of clip window\n                y = y0 + ((y1 - y0) * (left - x0)) / (x1 - x0);\n                x = left;\n            }\n\n            // Now we move outside point to intersection point to clip\n            // and get ready for next pass.\n            if (outcodeOut == outcode0) {\n                x0 = x!;\n                y0 = y!;\n                outcode0 = outCode(x0, y0, boundingBox);\n            } else {\n                x1 = x!;\n                y1 = y!;\n                outcode1 = outCode(x1, y1, boundingBox);\n            }\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Vector } from \"./Vector\";\n\nexport type AABB = {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n};\n\nexport function boundingBoxContainsPoint(boundingBox: AABB, point: Vector) {\n    return (\n        point[0] >= boundingBox.left &&\n        point[0] <= boundingBox.right &&\n        point[1] >= boundingBox.top &&\n        point[1] <= boundingBox.bottom\n    );\n}\n\nexport function boundingBoxesOverlap(a: AABB, b: AABB) {\n    return (\n        a.left <= b.right &&\n        b.left <= a.right &&\n        a.top <= b.bottom &&\n        b.top <= a.bottom\n    );\n}\n\nexport function mergeBoundingBoxes(a: AABB | null, b: AABB): AABB {\n    if (!a) return b;\n\n    return {\n        top: Math.min(a.top, b.top),\n        right: Math.max(a.right, b.right),\n        bottom: Math.max(a.bottom, b.bottom),\n        left: Math.min(a.left, b.left),\n    };\n}\n\nexport function extendBoundingBox(boundingBox: AABB | null, point: Vector) {\n    if (!boundingBox) {\n        return {\n            top: point[1],\n            right: point[0],\n            bottom: point[1],\n            left: point[0],\n        };\n    }\n\n    return {\n        top: Math.min(boundingBox.top, point[1]),\n        right: Math.max(boundingBox.right, point[0]),\n        bottom: Math.max(boundingBox.bottom, point[1]),\n        left: Math.min(boundingBox.left, point[0]),\n    };\n}\n\nexport function boundingBoxMaxExtent(boundingBox: AABB) {\n    return Math.max(\n        boundingBox.right - boundingBox.left,\n        boundingBox.bottom - boundingBox.top,\n    );\n}\n\nexport function boundingBoxAroundPoint(point: Vector, padding: number): AABB {\n    return {\n        top: point[1] - padding,\n        right: point[0] + padding,\n        bottom: point[1] + padding,\n        left: point[0] - padding,\n    };\n}\n\nexport function expandBoundingBox(boundingBox: AABB, padding: number): AABB {\n    return {\n        top: boundingBox.top - padding,\n        right: boundingBox.right + padding,\n        bottom: boundingBox.bottom + padding,\n        left: boundingBox.left - padding,\n    };\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { lineSegmentAABBIntersect } from \"./intersections/line-segment-AABB\";\nimport {\n    AABB,\n    boundingBoxesOverlap,\n    mergeBoundingBoxes,\n} from \"./primitives/AABB\";\nimport { Vector } from \"./primitives/Vector\";\n\ntype LineSegment = [Vector, Vector];\n\nexport class QuadTree<T> {\n    static fromPairs<T>(\n        pairs: [AABB, T][],\n        depth: number,\n        innerNodeCapacity: number = 8,\n    ): QuadTree<T> {\n        if (pairs.length === 0) {\n            throw new Error(\"QuadTree.fromPairs: at least one pair needed.\");\n        }\n\n        let boundingBox = pairs[0][0];\n        for (let i = 1; i < pairs.length; i++) {\n            boundingBox = mergeBoundingBoxes(boundingBox, pairs[i][0]);\n        }\n\n        const tree = new QuadTree<T>(boundingBox, depth, innerNodeCapacity);\n\n        for (const [key, value] of pairs) {\n            tree.insert(key, value);\n        }\n\n        return tree;\n    }\n\n    protected subtrees:\n        | [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>]\n        | null = null;\n    protected pairs: [AABB, T][] = [];\n\n    constructor(\n        readonly boundingBox: AABB,\n        readonly depth: number,\n        readonly innerNodeCapacity: number = 16,\n    ) {}\n\n    insert(boundingBox: AABB, value: T) {\n        if (!boundingBoxesOverlap(boundingBox, this.boundingBox)) return false;\n\n        if (this.depth > 0 && this.pairs.length >= this.innerNodeCapacity) {\n            this.ensureSubtrees();\n            for (let i = 0; i < this.subtrees!.length; i++) {\n                const tree = this.subtrees![i];\n                tree.insert(boundingBox, value);\n            }\n        } else {\n            this.pairs.push([boundingBox, value]);\n        }\n\n        return true;\n    }\n\n    find(boundingBox: AABB, set: Set<T> = new Set()): Set<T> {\n        if (!boundingBoxesOverlap(boundingBox, this.boundingBox)) return set;\n\n        for (let i = 0; i < this.pairs.length; i++) {\n            const [key, value] = this.pairs[i];\n            if (boundingBoxesOverlap(boundingBox, key)) {\n                set.add(value);\n            }\n        }\n\n        if (this.subtrees) {\n            for (let i = 0; i < this.subtrees.length; i++) {\n                const tree = this.subtrees[i];\n                tree.find(boundingBox, set);\n            }\n        }\n\n        return set;\n    }\n\n    findOnLineSegment(seg: LineSegment, set: Set<T> = new Set()): Set<T> {\n        if (!lineSegmentAABBIntersect(seg, this.boundingBox)) return set;\n\n        for (const [key, value] of this.pairs) {\n            if (lineSegmentAABBIntersect(seg, key)) {\n                set.add(value);\n            }\n        }\n\n        if (this.subtrees) {\n            for (const tree of this.subtrees) {\n                tree.findOnLineSegment(seg, set);\n            }\n        }\n\n        return set;\n    }\n\n    private ensureSubtrees() {\n        if (this.subtrees) return;\n\n        const { top, right, bottom, left } = this.boundingBox;\n        const midX = (this.boundingBox.left + this.boundingBox.right) / 2;\n        const midY = (this.boundingBox.top + this.boundingBox.bottom) / 2;\n\n        this.subtrees = [\n            new QuadTree(\n                { top, right: midX, bottom: midY, left },\n                this.depth - 1,\n                this.innerNodeCapacity,\n            ),\n            new QuadTree(\n                { top, right, bottom: midY, left: midX },\n                this.depth - 1,\n                this.innerNodeCapacity,\n            ),\n            new QuadTree(\n                { top: midY, right: midX, bottom, left },\n                this.depth - 1,\n                this.innerNodeCapacity,\n            ),\n            new QuadTree(\n                { top: midY, right, bottom, left: midX },\n                this.depth - 1,\n                this.innerNodeCapacity,\n            ),\n        ];\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { PathCubicSegment } from \"../primitives/PathSegment\";\n\nconst EPS = 1e-12;\n\nexport function pathCubicSegmentSelfIntersection(\n    seg: PathCubicSegment,\n): [number, number] | null {\n    // https://math.stackexchange.com/questions/3931865/self-intersection-of-a-cubic-bezier-interpretation-of-the-solution\n\n    const A = seg[1];\n    const B = seg[2];\n    const C = seg[3];\n    const D = seg[4];\n\n    const ax = -A[0] + 3 * B[0] - 3 * C[0] + D[0];\n    const ay = -A[1] + 3 * B[1] - 3 * C[1] + D[1];\n    const bx = 3 * A[0] - 6 * B[0] + 3 * C[0];\n    const by = 3 * A[1] - 6 * B[1] + 3 * C[1];\n    const cx = -3 * A[0] + 3 * B[0];\n    const cy = -3 * A[1] + 3 * B[1];\n\n    const M = ay * bx - ax * by;\n    const N = ax * cy - ay * cx;\n\n    const K =\n        (-3 * ax * ax * cy * cy +\n            6 * ax * ay * cx * cy +\n            4 * ax * bx * by * cy -\n            4 * ax * by * by * cx -\n            3 * ay * ay * cx * cx -\n            4 * ay * bx * bx * cy +\n            4 * ay * bx * by * cx) /\n        (ax * ax * by * by - 2 * ax * ay * bx * by + ay * ay * bx * bx);\n\n    if (K < 0) return null;\n\n    const t1 = (N / M + Math.sqrt(K)) / 2;\n    const t2 = (N / M - Math.sqrt(K)) / 2;\n\n    if (EPS <= t1 && t1 <= 1 - EPS && EPS <= t2 && t2 <= 1 - EPS) {\n        return [t1, t2];\n    }\n\n    return null;\n}\n","/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 2x2 Matrix\n * @module mat2\n */\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\n\nexport function fromValues(m00, m01, m10, m11) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\n\nexport function set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3]; // Calculate the determinant\n\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n  return out;\n}\n/**\n * Calculates the determinant of a mat2\n *\n * @param {ReadonlyMat2} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n/**\n * Returns a string representation of a mat2\n *\n * @param {ReadonlyMat2} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3]);\n}\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {ReadonlyMat2} L the lower triangular matrix\n * @param {ReadonlyMat2} D the diagonal matrix\n * @param {ReadonlyMat2} U the upper triangular matrix\n * @param {ReadonlyMat2} a the input matrix to factorize\n */\n\nexport function LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 2x3 Matrix\n * @module mat2d\n * @description\n * A mat2d contains six elements defined as:\n * <pre>\n * [a, b,\n *  c, d,\n *  tx, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, b, 0,\n *  c, d, 0,\n *  tx, ty, 1]\n * </pre>\n * The last column is ignored so the array is shorter and operations are faster.\n */\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(6);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {mat2d} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\n\nexport function fromValues(a, b, c, d, tx, ty) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\n\nexport function set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {mat2d} out\n */\n\nexport function invert(out, a) {\n  var aa = a[0],\n      ab = a[1],\n      ac = a[2],\n      ad = a[3];\n  var atx = a[4],\n      aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to translate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to translate\n * @param {ReadonlyVec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\n\nexport function translate(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2d} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat2d} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n/**\n * Returns a string representation of a mat2d\n *\n * @param {ReadonlyMat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat2d(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);\n}\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2d} a The first matrix.\n * @param {ReadonlyMat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2d} a The first matrix.\n * @param {ReadonlyMat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));\n}\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { vec2 } from \"gl-matrix\";\n\nexport const TAU = 2 * Math.PI;\n\nexport function linMap(\n    value: number,\n    inMin: number,\n    inMax: number,\n    outMin: number,\n    outMax: number,\n) {\n    return ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;\n}\n\nexport function lerp(a: number, b: number, t: number) {\n    return a + (b - a) * t;\n}\n\nexport function rad2deg(rad: number) {\n    return (rad / Math.PI) * 180;\n}\n\nexport function deg2rad(deg: number) {\n    return (deg / 180) * Math.PI;\n}\n\nexport function vectorAngle(u: [number, number], v: [number, number]) {\n    const EPS = 1e-12;\n\n    const sign = Math.sign(u[0] * v[1] - u[1] * v[0]);\n\n    if (\n        sign === 0 &&\n        Math.abs(u[0] + v[0]) < EPS &&\n        Math.abs(u[1] + v[1]) < EPS\n    ) {\n        // TODO: u can be scaled\n        return Math.PI;\n    }\n\n    return sign * Math.acos(vec2.dot(u, v) / vec2.len(u) / vec2.len(v));\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\n\nexport type Vector = [number, number];\n\nexport function createVector(): Vector {\n    return [0, 0];\n}\n\nexport function vectorsEqual(a: Vector, b: Vector, eps: number = 0) {\n    return Math.abs(a[0] - b[0]) <= eps && Math.abs(a[1] - b[1]) <= eps;\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { mat2, mat2d, vec2 } from \"gl-matrix\";\n\nimport { deg2rad, lerp, TAU, vectorAngle } from \"../util/math\";\nimport {\n    AABB,\n    boundingBoxAroundPoint,\n    expandBoundingBox,\n    extendBoundingBox,\n    mergeBoundingBoxes,\n} from \"./AABB\";\nimport { createVector, Vector } from \"./Vector\";\n\nexport type PathLineSegment = [\"L\", Vector, Vector];\n\nexport type PathCubicSegment = [\"C\", Vector, Vector, Vector, Vector];\n\nexport type PathQuadraticSegment = [\"Q\", Vector, Vector, Vector];\n\nexport type PathArcSegment = [\n    \"A\",\n    Vector,\n    number, // rx\n    number, // ry\n    number, // rotation\n    boolean, // large-arc-flag\n    boolean, // sweep-flag\n    Vector,\n];\n\nexport type PathSegment =\n    | PathLineSegment\n    | PathCubicSegment\n    | PathQuadraticSegment\n    | PathArcSegment;\n\ntype PathArcSegmentCenterParametrization = {\n    center: Vector;\n    theta1: number;\n    deltaTheta: number;\n    rx: number;\n    ry: number;\n    phi: number;\n};\n\nexport function getStartPoint(seg: PathSegment): Vector {\n    return seg[1];\n}\n\nexport function getEndPoint(seg: PathSegment): Vector {\n    switch (seg[0]) {\n        case \"L\":\n            return seg[2];\n        case \"C\":\n            return seg[4];\n        case \"Q\":\n            return seg[3];\n        case \"A\":\n            return seg[7];\n    }\n}\n\nexport function reversePathSegment(seg: PathSegment): PathSegment {\n    switch (seg[0]) {\n        case \"L\":\n            return [\"L\", seg[2], seg[1]];\n        case \"C\":\n            return [\"C\", seg[4], seg[3], seg[2], seg[1]];\n        case \"Q\":\n            return [\"Q\", seg[3], seg[2], seg[1]];\n        case \"A\":\n            return [\n                \"A\",\n                seg[7],\n                seg[2],\n                seg[3],\n                seg[4],\n                seg[5],\n                !seg[6],\n                seg[1],\n            ];\n    }\n}\n\nexport const arcSegmentToCenter = (() => {\n    const xy1Prime = createVector();\n    const rotationMatrix = mat2.create();\n    const addend = createVector();\n    const cxy = createVector();\n\n    return function arcSegmentToCenter([\n        _A,\n        xy1,\n        rx,\n        ry,\n        phi,\n        fA,\n        fS,\n        xy2,\n    ]: PathArcSegment): PathArcSegmentCenterParametrization | null {\n        // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n        if (rx === 0 || ry === 0) {\n            return null;\n        }\n\n        // https://svgwg.org/svg2-draft/implnote.html#ArcConversionEndpointToCenter\n\n        mat2.fromRotation(rotationMatrix, -deg2rad(phi));\n\n        vec2.sub(xy1Prime, xy1, xy2);\n        vec2.scale(xy1Prime, xy1Prime, 0.5);\n        vec2.transformMat2(xy1Prime, xy1Prime, rotationMatrix);\n\n        let rx2 = rx * rx;\n        let ry2 = ry * ry;\n        const x1Prime2 = xy1Prime[0] * xy1Prime[0];\n        const y1Prime2 = xy1Prime[1] * xy1Prime[1];\n\n        // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        const lambda = x1Prime2 / rx2 + y1Prime2 / ry2 + 1e-12; // small epsilon needed because of float precision\n        if (lambda > 1) {\n            const lambdaSqrt = Math.sqrt(lambda);\n            rx *= lambdaSqrt;\n            ry *= lambdaSqrt;\n            const lambdaAbs = Math.abs(lambda);\n            rx2 *= lambdaAbs;\n            ry2 *= lambdaAbs;\n        }\n\n        const sign = fA === fS ? -1 : 1;\n        const multiplier = Math.sqrt(\n            (rx2 * ry2 - rx2 * y1Prime2 - ry2 * x1Prime2) /\n                (rx2 * y1Prime2 + ry2 * x1Prime2),\n        );\n        const cxPrime = sign * multiplier * ((rx * xy1Prime[1]) / ry);\n        const cyPrime = sign * multiplier * ((-ry * xy1Prime[0]) / rx);\n\n        mat2.transpose(rotationMatrix, rotationMatrix);\n        vec2.add(addend, xy1, xy2);\n        vec2.scale(addend, addend, 0.5);\n        vec2.transformMat2(cxy, [cxPrime, cyPrime], rotationMatrix);\n        vec2.add(cxy, cxy, addend);\n\n        const vec1: Vector = [\n            (xy1Prime[0] - cxPrime) / rx,\n            (xy1Prime[1] - cyPrime) / ry,\n        ];\n        const theta1 = vectorAngle([1, 0], vec1);\n        let deltaTheta = vectorAngle(vec1, [\n            (-xy1Prime[0] - cxPrime) / rx,\n            (-xy1Prime[1] - cyPrime) / ry,\n        ]);\n\n        if (!fS && deltaTheta > 0) {\n            deltaTheta -= TAU;\n        } else if (fS && deltaTheta < 0) {\n            deltaTheta += TAU;\n        }\n\n        return {\n            center: [cxy[0], cxy[1]],\n            theta1,\n            deltaTheta,\n            rx,\n            ry,\n            phi,\n        };\n    };\n})();\n\nexport const arcSegmentFromCenter = (() => {\n    const xy1 = createVector();\n    const xy2 = createVector();\n    const rotationMatrix = mat2.create();\n\n    return function arcSegmentFromCenter({\n        center,\n        theta1,\n        deltaTheta,\n        rx,\n        ry,\n        phi,\n    }: PathArcSegmentCenterParametrization): PathArcSegment {\n        // https://svgwg.org/svg2-draft/implnote.html#ArcConversionCenterToEndpoint\n        mat2.fromRotation(rotationMatrix, phi); // TODO: sign (also in sampleAt)\n\n        vec2.set(xy1, rx * Math.cos(theta1), ry * Math.sin(theta1));\n        vec2.transformMat2(xy1, xy1, rotationMatrix);\n        vec2.add(xy1, xy1, center);\n\n        vec2.set(\n            xy2,\n            rx * Math.cos(theta1 + deltaTheta),\n            ry * Math.sin(theta1 + deltaTheta),\n        );\n        vec2.transformMat2(xy2, xy2, rotationMatrix);\n        vec2.add(xy2, xy2, center);\n\n        const fA = Math.abs(deltaTheta) > Math.PI;\n\n        const fS = deltaTheta > 0;\n\n        return [\"A\", [xy1[0], xy1[1]], rx, ry, phi, fA, fS, [xy2[0], xy2[1]]];\n    };\n})();\n\nexport const samplePathSegmentAt = (() => {\n    const p01 = createVector();\n    const p12 = createVector();\n    const p23 = createVector();\n    const p012 = createVector();\n    const p123 = createVector();\n    const p = createVector();\n\n    return function samplePathSegmentAt(seg: PathSegment, t: number): Vector {\n        switch (seg[0]) {\n            case \"L\":\n                vec2.lerp(p, seg[1], seg[2], t);\n                break;\n            case \"C\":\n                vec2.lerp(p01, seg[1], seg[2], t);\n                vec2.lerp(p12, seg[2], seg[3], t);\n                vec2.lerp(p23, seg[3], seg[4], t);\n                vec2.lerp(p012, p01, p12, t);\n                vec2.lerp(p123, p12, p23, t);\n                vec2.lerp(p, p012, p123, t);\n                break;\n            case \"Q\":\n                vec2.lerp(p01, seg[1], seg[2], t);\n                vec2.lerp(p12, seg[2], seg[3], t);\n                vec2.lerp(p, p01, p12, t);\n                break;\n            case \"A\": {\n                const centerParametrization = arcSegmentToCenter(seg);\n                if (!centerParametrization) {\n                    // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n                    vec2.lerp(p, seg[1], seg[7], t);\n                    break;\n                }\n                const { deltaTheta, phi, theta1, rx, ry, center } =\n                    centerParametrization;\n                const theta = theta1 + t * deltaTheta;\n                vec2.set(p, rx * Math.cos(theta), ry * Math.sin(theta));\n                vec2.rotate(p, p, [0, 0], phi); // TODO: sign (also in fromCenter)\n                vec2.add(p, p, center);\n                break;\n            }\n        }\n\n        return [p[0], p[1]];\n    };\n})();\n\nexport const arcSegmentToCubics = (() => {\n    const fromUnit = mat2d.create();\n    const matrix = mat2d.create();\n\n    return function arcSegmentToCubics(\n        arc: PathArcSegment,\n        maxDeltaTheta: number = Math.PI / 2,\n    ): PathCubicSegment[] | [PathLineSegment] {\n        const centerParametrization = arcSegmentToCenter(arc);\n\n        if (!centerParametrization) {\n            // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n            // \"If rx = 0 or ry = 0, then treat this as a straight line from (x1, y1) to (x2, y2) and stop.\"\n            return [[\"L\", arc[1], arc[7]]];\n        }\n\n        const { center, theta1, deltaTheta, rx, ry } = centerParametrization;\n\n        const count = Math.ceil(Math.abs(deltaTheta) / maxDeltaTheta);\n\n        mat2d.fromTranslation(fromUnit, center);\n        mat2d.rotate(fromUnit, fromUnit, deg2rad(arc[4]));\n        mat2d.scale(fromUnit, fromUnit, [rx, ry]);\n\n        // https://pomax.github.io/bezierinfo/#circles_cubic\n        const cubics: PathCubicSegment[] = [];\n        const theta = deltaTheta / count;\n        const k = (4 / 3) * Math.tan(theta / 4);\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n        for (let i = 0; i < count; i++) {\n            const start: Vector = [1, 0];\n            const control1: Vector = [1, k];\n            const control2: Vector = [\n                cosTheta + k * sinTheta,\n                sinTheta - k * cosTheta,\n            ];\n            const end: Vector = [cosTheta, sinTheta];\n\n            mat2d.fromRotation(matrix, theta1 + i * theta);\n            mat2d.mul(matrix, fromUnit, matrix);\n            vec2.transformMat2d(start, start, matrix);\n            vec2.transformMat2d(control1, control1, matrix);\n            vec2.transformMat2d(control2, control2, matrix);\n            vec2.transformMat2d(end, end, matrix);\n\n            cubics.push([\"C\", start, control1, control2, end]);\n        }\n\n        return cubics;\n    };\n})();\n\nfunction evalCubic1d(\n    p0: number,\n    p1: number,\n    p2: number,\n    p3: number,\n    t: number,\n) {\n    const p01 = lerp(p0, p1, t);\n    const p12 = lerp(p1, p2, t);\n    const p23 = lerp(p2, p3, t);\n    const p012 = lerp(p01, p12, t);\n    const p123 = lerp(p12, p23, t);\n    return lerp(p012, p123, t);\n}\n\nfunction cubicBoundingInterval(p0: number, p1: number, p2: number, p3: number) {\n    let min = Math.min(p0, p3);\n    let max = Math.max(p0, p3);\n\n    const a = 3 * (-p0 + 3 * p1 - 3 * p2 + p3);\n    const b = 6 * (p0 - 2 * p1 + p2);\n    const c = 3 * (p1 - p0);\n    const D = b * b - 4 * a * c;\n\n    if (D < 0 || a === 0) {\n        // TODO: if a=0, solve linear\n        return [min, max];\n    }\n\n    const sqrtD = Math.sqrt(D);\n\n    const t0 = (-b - sqrtD) / (2 * a);\n    if (0 < t0 && t0 < 1) {\n        const x0 = evalCubic1d(p0, p1, p2, p3, t0);\n        min = Math.min(min, x0);\n        max = Math.max(max, x0);\n    }\n\n    const t1 = (-b + sqrtD) / (2 * a);\n    if (0 < t1 && t1 < 1) {\n        const x1 = evalCubic1d(p0, p1, p2, p3, t1);\n        min = Math.min(min, x1);\n        max = Math.max(max, x1);\n    }\n\n    return [min, max];\n}\n\nfunction evalQuadratic1d(p0: number, p1: number, p2: number, t: number) {\n    const p01 = lerp(p0, p1, t);\n    const p12 = lerp(p1, p2, t);\n    return lerp(p01, p12, t);\n}\n\nfunction quadraticBoundingInterval(p0: number, p1: number, p2: number) {\n    let min = Math.min(p0, p2);\n    let max = Math.max(p0, p2);\n\n    const denominator = p0 - 2 * p1 + p2;\n\n    if (denominator === 0) {\n        return [min, max];\n    }\n\n    const t = (p0 - p1) / denominator;\n    if (0 <= t && t <= 1) {\n        const x = evalQuadratic1d(p0, p1, p2, t);\n        min = Math.min(min, x);\n        max = Math.max(max, x);\n    }\n\n    return [min, max];\n}\n\nfunction inInterval(x: number, x0: number, x1: number) {\n    const mapped = (x - x0) / (x1 - x0);\n    return 0 <= mapped && mapped <= 1;\n}\n\nexport function pathSegmentBoundingBox(seg: PathSegment): AABB {\n    switch (seg[0]) {\n        case \"L\":\n            return {\n                top: Math.min(seg[1][1], seg[2][1]),\n                right: Math.max(seg[1][0], seg[2][0]),\n                bottom: Math.max(seg[1][1], seg[2][1]),\n                left: Math.min(seg[1][0], seg[2][0]),\n            };\n        case \"C\": {\n            const [left, right] = cubicBoundingInterval(\n                seg[1][0],\n                seg[2][0],\n                seg[3][0],\n                seg[4][0],\n            );\n            const [top, bottom] = cubicBoundingInterval(\n                seg[1][1],\n                seg[2][1],\n                seg[3][1],\n                seg[4][1],\n            );\n            return { top, right, bottom, left };\n        }\n        case \"Q\": {\n            const [left, right] = quadraticBoundingInterval(\n                seg[1][0],\n                seg[2][0],\n                seg[3][0],\n            );\n            const [top, bottom] = quadraticBoundingInterval(\n                seg[1][1],\n                seg[2][1],\n                seg[3][1],\n            );\n            return { top, right, bottom, left };\n        }\n        case \"A\": {\n            const centerParametrization = arcSegmentToCenter(seg);\n\n            if (!centerParametrization) {\n                return extendBoundingBox(\n                    boundingBoxAroundPoint(seg[1], 0),\n                    seg[7],\n                );\n            }\n\n            const { theta1, deltaTheta, phi, center, rx, ry } =\n                centerParametrization;\n\n            if (phi === 0 || rx === ry) {\n                const theta2 = theta1 + deltaTheta;\n                let boundingBox = extendBoundingBox(\n                    boundingBoxAroundPoint(seg[1], 0),\n                    seg[7],\n                );\n                // FIXME: the following gives false positives, resulting in larger boxes\n                if (\n                    inInterval(-Math.PI, theta1, theta2) ||\n                    inInterval(Math.PI, theta1, theta2)\n                ) {\n                    boundingBox = extendBoundingBox(boundingBox, [\n                        center[0] - rx,\n                        center[1],\n                    ]);\n                }\n                if (\n                    inInterval(-Math.PI / 2, theta1, theta2) ||\n                    inInterval((3 * Math.PI) / 2, theta1, theta2)\n                ) {\n                    boundingBox = extendBoundingBox(boundingBox, [\n                        center[0],\n                        center[1] - ry,\n                    ]);\n                }\n                if (\n                    inInterval(0, theta1, theta2) ||\n                    inInterval(2 * Math.PI, theta1, theta2)\n                ) {\n                    boundingBox = extendBoundingBox(boundingBox, [\n                        center[0] + rx,\n                        center[1],\n                    ]);\n                }\n                if (\n                    inInterval(Math.PI / 2, theta1, theta2) ||\n                    inInterval((5 * Math.PI) / 2, theta1, theta2)\n                ) {\n                    boundingBox = extendBoundingBox(boundingBox, [\n                        center[0],\n                        center[1] + ry,\n                    ]);\n                }\n                return expandBoundingBox(boundingBox, 1e-11); // TODO: get rid of expansion\n            }\n\n            // TODO: don't convert to cubics\n            const cubics = arcSegmentToCubics(seg, Math.PI / 16);\n            let boundingBox: AABB | null = null;\n            for (const seg of cubics) {\n                boundingBox = mergeBoundingBoxes(\n                    boundingBox,\n                    pathSegmentBoundingBox(seg),\n                );\n            }\n            if (!boundingBox) {\n                return boundingBoxAroundPoint(seg[1], 0); //  TODO: what to do here?\n            }\n            return boundingBox;\n        }\n    }\n}\n\nfunction splitLinearSegmentAt(\n    seg: PathLineSegment,\n    t: number,\n): [PathLineSegment, PathLineSegment] {\n    const a = seg[1];\n    const b = seg[2];\n\n    const p = vec2.lerp(createVector(), a, b, t) as Vector;\n\n    return [\n        [\"L\", a, p],\n        [\"L\", p, b],\n    ];\n}\n\nexport function splitCubicSegmentAt(\n    seg: PathCubicSegment,\n    t: number,\n): [PathCubicSegment, PathCubicSegment] {\n    // https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n    const p0 = seg[1];\n    const p1 = seg[2];\n    const p2 = seg[3];\n    const p3 = seg[4];\n\n    const p01 = vec2.lerp(createVector(), p0, p1, t) as Vector;\n    const p12 = vec2.lerp(createVector(), p1, p2, t) as Vector;\n    const p23 = vec2.lerp(createVector(), p2, p3, t) as Vector;\n    const p012 = vec2.lerp(createVector(), p01, p12, t) as Vector;\n    const p123 = vec2.lerp(createVector(), p12, p23, t) as Vector;\n    const p = vec2.lerp(createVector(), p012, p123, t) as Vector;\n\n    return [\n        [\"C\", p0, p01, p012, p],\n        [\"C\", p, p123, p23, p3],\n    ];\n}\n\nfunction splitQuadraticSegmentAt(\n    seg: PathQuadraticSegment,\n    t: number,\n): [PathQuadraticSegment, PathQuadraticSegment] {\n    // https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n    const p0 = seg[1];\n    const p1 = seg[2];\n    const p2 = seg[3];\n\n    const p01 = vec2.lerp(createVector(), p0, p1, t) as Vector;\n    const p12 = vec2.lerp(createVector(), p1, p2, t) as Vector;\n    const p = vec2.lerp(createVector(), p01, p12, t) as Vector;\n\n    return [\n        [\"Q\", p0, p01, p],\n        [\"Q\", p, p12, p2],\n    ];\n}\n\nfunction splitArcSegmentAt(\n    seg: PathArcSegment,\n    t: number,\n): [PathArcSegment, PathArcSegment] | [PathLineSegment, PathLineSegment] {\n    const centerParametrization = arcSegmentToCenter(seg);\n\n    if (!centerParametrization) {\n        // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n        return splitLinearSegmentAt([\"L\", seg[1], seg[7]], t);\n    }\n\n    const midDeltaTheta = centerParametrization.deltaTheta * t;\n    return [\n        arcSegmentFromCenter({\n            ...centerParametrization,\n            deltaTheta: midDeltaTheta,\n        }),\n        arcSegmentFromCenter({\n            ...centerParametrization,\n            theta1: centerParametrization.theta1 + midDeltaTheta,\n            deltaTheta: centerParametrization.deltaTheta - midDeltaTheta,\n        }),\n    ];\n}\n\nexport function splitSegmentAt(\n    seg: PathSegment,\n    t: number,\n): [PathSegment, PathSegment] {\n    switch (seg[0]) {\n        case \"L\":\n            return splitLinearSegmentAt(seg, t);\n        case \"C\":\n            return splitCubicSegmentAt(seg, t);\n        case \"Q\":\n            return splitQuadraticSegmentAt(seg, t);\n        case \"A\":\n            return splitArcSegmentAt(seg, t);\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Vector } from \"../primitives/Vector\";\n\ntype LineSegment = [Vector, Vector];\n\nconst COLLINEAR_EPS = Number.MIN_VALUE * 64;\n\nexport function lineSegmentIntersection(\n    [[x1, y1], [x2, y2]]: LineSegment,\n    [[x3, y3], [x4, y4]]: LineSegment,\n    eps: number,\n): [number, number] | null {\n    // https://en.wikipedia.org/wiki/Intersection_(geometry)#Two_line_segments\n\n    const a1 = x2 - x1;\n    const b1 = x3 - x4;\n    const c1 = x3 - x1;\n    const a2 = y2 - y1;\n    const b2 = y3 - y4;\n    const c2 = y3 - y1;\n\n    const denom = a1 * b2 - a2 * b1;\n\n    if (Math.abs(denom) < COLLINEAR_EPS) return null;\n\n    const s = (c1 * b2 - c2 * b1) / denom;\n    const t = (a1 * c2 - a2 * c1) / denom;\n\n    if (-eps <= s && s <= 1 + eps && -eps <= t && t <= 1 + eps) {\n        return [s, t];\n    }\n\n    return null;\n}\n\nexport function lineSegmentsIntersect(\n    seg1: LineSegment,\n    seg2: LineSegment,\n    eps: number,\n) {\n    return !!lineSegmentIntersection(seg1, seg2, eps);\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Epsilons } from \"../Epsilons\";\nimport {\n    AABB,\n    boundingBoxesOverlap,\n    boundingBoxMaxExtent,\n} from \"../primitives/AABB\";\nimport {\n    PathSegment,\n    pathSegmentBoundingBox,\n    splitSegmentAt,\n} from \"../primitives/PathSegment\";\nimport { Vector, vectorsEqual } from \"../primitives/Vector\";\nimport { lerp } from \"../util/math\";\nimport { lineSegmentIntersection, lineSegmentsIntersect } from \"./line-segment\";\nimport { lineSegmentAABBIntersect } from \"./line-segment-AABB\";\n\ntype IntersectionSegment = {\n    seg: PathSegment;\n    startParam: number;\n    endParam: number;\n    boundingBox: AABB;\n};\n\nfunction subdivideIntersectionSegment(\n    intSeg: IntersectionSegment,\n): IntersectionSegment[] {\n    const [seg0, seg1] = splitSegmentAt(intSeg.seg, 0.5);\n    const midParam = (intSeg.startParam + intSeg.endParam) / 2;\n    return [\n        {\n            seg: seg0,\n            startParam: intSeg.startParam,\n            endParam: midParam,\n            boundingBox: pathSegmentBoundingBox(seg0),\n        },\n        {\n            seg: seg1,\n            startParam: midParam,\n            endParam: intSeg.endParam,\n            boundingBox: pathSegmentBoundingBox(seg1),\n        },\n    ];\n}\n\nfunction pathSegmentToLineSegment(seg: PathSegment): [Vector, Vector] {\n    switch (seg[0]) {\n        case \"L\":\n            return [seg[1], seg[2]];\n        case \"C\":\n            return [seg[1], seg[4]];\n        case \"Q\":\n            return [seg[1], seg[3]];\n        case \"A\":\n            return [seg[1], seg[7]];\n    }\n}\n\nfunction intersectionSegmentsOverlap(\n    { seg: seg0, boundingBox: boundingBox0 }: IntersectionSegment,\n    { seg: seg1, boundingBox: boundingBox1 }: IntersectionSegment,\n) {\n    if (seg0[0] === \"L\") {\n        if (seg1[0] === \"L\") {\n            return lineSegmentsIntersect(\n                [seg0[1], seg0[2]],\n                [seg1[1], seg1[2]],\n                1e-6, // TODO: configurable\n            );\n        } else {\n            return lineSegmentAABBIntersect([seg0[1], seg0[2]], boundingBox1);\n        }\n    } else {\n        if (seg1[0] === \"L\") {\n            return lineSegmentAABBIntersect([seg1[1], seg1[2]], boundingBox0);\n        } else {\n            return boundingBoxesOverlap(boundingBox0, boundingBox1);\n        }\n    }\n}\n\nexport function segmentsEqual(\n    seg0: PathSegment,\n    seg1: PathSegment,\n    pointEpsilon: number,\n): boolean {\n    const type = seg0[0];\n\n    if (seg1[0] !== type) return false;\n\n    switch (type) {\n        case \"L\":\n            return (\n                vectorsEqual(seg0[1], seg1[1], pointEpsilon) &&\n                vectorsEqual(seg0[2], seg1[2] as Vector, pointEpsilon)\n            );\n        case \"C\":\n            return (\n                vectorsEqual(seg0[1], seg1[1], pointEpsilon) &&\n                vectorsEqual(seg0[2], seg1[2] as Vector, pointEpsilon) &&\n                vectorsEqual(seg0[3], seg1[3] as Vector, pointEpsilon) &&\n                vectorsEqual(seg0[4], seg1[4] as Vector, pointEpsilon)\n            );\n        case \"Q\":\n            return (\n                vectorsEqual(seg0[1], seg1[1], pointEpsilon) &&\n                vectorsEqual(seg0[2], seg1[2] as Vector, pointEpsilon) &&\n                vectorsEqual(seg0[3], seg1[3] as Vector, pointEpsilon)\n            );\n        case \"A\":\n            return (\n                vectorsEqual(seg0[1], seg1[1], pointEpsilon) &&\n                Math.abs(seg0[2] - (seg1[2] as number)) < pointEpsilon &&\n                Math.abs(seg0[3] - (seg1[3] as number)) < pointEpsilon &&\n                Math.abs(seg0[4] - (seg1[4] as number)) < pointEpsilon && // TODO: Phi can be anything if rx = ry. Also, handle rotations by Pi/2.\n                seg0[5] === seg1[5] &&\n                seg0[6] === seg1[6] &&\n                vectorsEqual(seg0[7], seg1[7] as Vector, pointEpsilon)\n            );\n    }\n}\n\nexport function pathSegmentIntersection(\n    seg0: PathSegment,\n    seg1: PathSegment,\n    endpoints: boolean,\n    eps: Epsilons,\n): [number, number][] {\n    if (seg0[0] === \"L\" && seg1[0] === \"L\") {\n        const st = lineSegmentIntersection(\n            [seg0[1], seg0[2]],\n            [seg1[1], seg1[2]],\n            eps.param,\n        );\n        if (st) {\n            if (\n                !endpoints &&\n                (st[0] < eps.param || st[0] > 1 - eps.param) &&\n                (st[1] < eps.param || st[1] > 1 - eps.param)\n            ) {\n                return [];\n            }\n            return [st];\n        }\n    }\n\n    // https://math.stackexchange.com/questions/20321/how-can-i-tell-when-two-cubic-b%C3%A9zier-curves-intersect\n\n    let pairs: [IntersectionSegment, IntersectionSegment][] = [\n        [\n            {\n                seg: seg0,\n                startParam: 0,\n                endParam: 1,\n                boundingBox: pathSegmentBoundingBox(seg0),\n            },\n            {\n                seg: seg1,\n                startParam: 0,\n                endParam: 1,\n                boundingBox: pathSegmentBoundingBox(seg1),\n            },\n        ],\n    ];\n\n    const params: [number, number][] = [];\n\n    while (pairs.length) {\n        const nextPairs: [IntersectionSegment, IntersectionSegment][] = [];\n\n        for (const [seg0, seg1] of pairs) {\n            if (segmentsEqual(seg0.seg, seg1.seg, eps.point)) {\n                // TODO: move this outside of this loop?\n                continue; // TODO: what to do?\n            }\n\n            const isLinear0 =\n                boundingBoxMaxExtent(seg0.boundingBox) <= eps.linear;\n            const isLinear1 =\n                boundingBoxMaxExtent(seg1.boundingBox) <= eps.linear;\n\n            if (isLinear0 && isLinear1) {\n                const lineSegment0 = pathSegmentToLineSegment(seg0.seg);\n                const lineSegment1 = pathSegmentToLineSegment(seg1.seg);\n                const st = lineSegmentIntersection(\n                    lineSegment0,\n                    lineSegment1,\n                    eps.param,\n                );\n                if (st) {\n                    params.push([\n                        lerp(seg0.startParam, seg0.endParam, st[0]),\n                        lerp(seg1.startParam, seg1.endParam, st[1]),\n                    ]);\n                }\n            } else {\n                const subdivided0 = isLinear0\n                    ? [seg0]\n                    : subdivideIntersectionSegment(seg0);\n                const subdivided1 = isLinear1\n                    ? [seg1]\n                    : subdivideIntersectionSegment(seg1);\n\n                for (const seg0 of subdivided0) {\n                    for (const seg1 of subdivided1) {\n                        if (intersectionSegmentsOverlap(seg0, seg1)) {\n                            nextPairs.push([seg0, seg1]);\n                        }\n                    }\n                }\n            }\n        }\n\n        pairs = nextPairs;\n    }\n\n    if (!endpoints) {\n        return params.filter(\n            ([s, t]) =>\n                (s > eps.param && s < 1 - eps.param) ||\n                (t > eps.param && t < 1 - eps.param),\n        );\n    }\n\n    return params;\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\n\nexport function isNumber(val: unknown): val is number {\n    return typeof val === \"number\";\n}\n\nexport function isString(val: unknown): val is string {\n    return typeof val === \"string\";\n}\n\nexport function isBoolean(val: unknown): val is boolean {\n    return typeof val === \"boolean\";\n}\n\nexport const hasOwn = Object.hasOwn;\n\nexport function memoizeWeak<Obj extends Object, Args, Ret>(\n    fn: (obj: Obj, ...args: Args[]) => Ret,\n) {\n    const cache = new WeakMap<Obj, Ret>();\n    return (obj: Obj, ...args: Args[]) => {\n        if (cache.has(obj)) {\n            return cache.get(obj)!;\n        } else {\n            const val = fn(obj, ...args);\n            cache.set(obj, val);\n            return val;\n        }\n    };\n}\n\nexport function countIf<T>(arr: T[], pred: (value: T) => boolean): number {\n    return arr.reduce((acc: number, item: T) => acc + (pred(item) ? 1 : 0), 0);\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\n\nexport function* map<T1, T2>(\n    iter: Iterable<T1>,\n    fn: (val: T1, index: number) => T2,\n): Iterable<T2> {\n    let i = 0;\n    for (const val of iter) {\n        yield fn(val, i++);\n    }\n}\n\nexport function* flatMap<T1, T2>(\n    iter: Iterable<T1>,\n    fn: (val: T1, index: number) => Iterable<T2>,\n): Iterable<T2> {\n    let i = 0;\n    for (const val of iter) {\n        yield* fn(val, i++);\n    }\n}\n\nexport function* filter<T>(\n    iter: Iterable<T>,\n    fn: (val: T) => boolean,\n): Iterable<T> {\n    for (const val of iter) {\n        if (fn(val)) {\n            yield val;\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Epsilons } from \"./Epsilons\";\nimport { QuadTree } from \"./QuadTree\";\nimport {\n    assertCondition,\n    assertDefined,\n    assertEqual,\n    assertUnreachable,\n} from \"./assert\";\nimport { pathCubicSegmentSelfIntersection } from \"./intersections/path-cubic-segment-self-intersection\";\nimport {\n    pathSegmentIntersection,\n    segmentsEqual,\n} from \"./intersections/path-segment\";\nimport {\n    AABB,\n    boundingBoxAroundPoint,\n    boundingBoxMaxExtent,\n    mergeBoundingBoxes,\n} from \"./primitives/AABB\";\nimport { Path } from \"./primitives/Path\";\nimport {\n    getEndPoint,\n    getStartPoint,\n    PathSegment,\n    pathSegmentBoundingBox,\n    reversePathSegment,\n    samplePathSegmentAt,\n    splitCubicSegmentAt,\n    splitSegmentAt,\n} from \"./primitives/PathSegment\";\nimport { Vector, vectorsEqual } from \"./primitives/Vector\";\nimport { countIf, hasOwn, memoizeWeak } from \"./util/generic\";\nimport { map } from \"./util/iterators\";\nimport { linMap } from \"./util/math\";\n\nconst INTERSECTION_TREE_DEPTH = 8;\nconst POINT_TREE_DEPTH = 8;\n\nconst EPS: Epsilons = {\n    point: 1e-6,\n    linear: 1e-4,\n    param: 1e-8,\n};\n\nexport enum PathBooleanOperation {\n    Union,\n    Difference,\n    Intersection,\n    Exclusion,\n    Division,\n    Fracture,\n}\n\nexport enum FillRule {\n    NonZero,\n    EvenOdd,\n}\n\ntype MajorGraphEdgeStage1 = {\n    seg: PathSegment;\n    parent: number;\n};\n\ntype MajorGraphEdgeStage2 = MajorGraphEdgeStage1 & {\n    boundingBox: AABB;\n};\n\ntype MajorGraphEdge = MajorGraphEdgeStage2 & {\n    incidentVertices: [MajorGraphVertex, MajorGraphVertex];\n    directionFlag: boolean;\n    twin: MajorGraphEdge | null;\n};\n\ntype MajorGraphVertex = {\n    point: Vector;\n    outgoingEdges: MajorGraphEdge[];\n};\n\ntype MajorGraph = {\n    edges: MajorGraphEdge[];\n    vertices: MajorGraphVertex[];\n};\n\ntype MinorGraphEdge = {\n    segments: PathSegment[];\n    parent: number;\n    incidentVertices: [MinorGraphVertex, MinorGraphVertex];\n    directionFlag: boolean;\n    twin: MinorGraphEdge | null;\n};\n\ntype MinorGraphVertex = {\n    outgoingEdges: MinorGraphEdge[];\n};\n\ntype MinorGraphCycle = {\n    segments: PathSegment[];\n    parent: number;\n    directionFlag: boolean;\n};\n\ntype MinorGraph = {\n    edges: MinorGraphEdge[];\n    vertices: MinorGraphVertex[];\n    cycles: MinorGraphCycle[];\n};\n\ntype DualGraphHalfEdge = {\n    segments: PathSegment[];\n    parent: number;\n    incidentVertex: DualGraphVertex;\n    directionFlag: boolean;\n    twin: DualGraphHalfEdge | null;\n};\n\ntype DualGraphVertex = {\n    incidentEdges: DualGraphHalfEdge[];\n    flag: number;\n};\n\ntype DualGraphComponent = {\n    edges: DualGraphHalfEdge[];\n    vertices: DualGraphVertex[];\n    outerFace: DualGraphVertex | null;\n};\n\ntype NestingTree = {\n    component: DualGraphComponent;\n    outgoingEdges: Map<DualGraphVertex, NestingTree[]>;\n};\n\nfunction firstElementOfSet<T>(set: Set<T>): T {\n    return set.values().next().value;\n}\n\nfunction createObjectCounter(): (obj: Object) => number {\n    let i = 0;\n    return memoizeWeak(() => i++);\n}\n\nfunction segmentToEdge(\n    parent: 1 | 2,\n): (seg: PathSegment) => MajorGraphEdgeStage1 {\n    return (seg) => ({ seg, parent });\n}\n\nfunction splitAtSelfIntersections(edges: MajorGraphEdgeStage1[]) {\n    for (let i = 0; i < edges.length; i++) {\n        const edge = edges[i];\n        if (edge.seg[0] !== \"C\") continue;\n        const intersection = pathCubicSegmentSelfIntersection(edge.seg);\n        if (!intersection) continue;\n        if (intersection[0] > intersection[1]) {\n            intersection.reverse();\n        }\n        const [t1, t2] = intersection;\n        if (Math.abs(t1 - t2) < EPS.param) {\n            const [seg1, seg2] = splitCubicSegmentAt(edge.seg, t1);\n            edges[i] = {\n                seg: seg1,\n                parent: edge.parent,\n            };\n            edges.push({\n                seg: seg2,\n                parent: edge.parent,\n            });\n        } else {\n            const [seg1, tmpSeg] = splitCubicSegmentAt(edge.seg, t1);\n            const [seg2, seg3] = splitCubicSegmentAt(\n                tmpSeg,\n                (t2 - t1) / (1 - t1),\n            );\n            edges[i] = {\n                seg: seg1,\n                parent: edge.parent,\n            };\n            edges.push(\n                {\n                    seg: seg2,\n                    parent: edge.parent,\n                },\n                {\n                    seg: seg3,\n                    parent: edge.parent,\n                },\n            );\n        }\n    }\n}\n\nfunction splitAtIntersections(edges: MajorGraphEdgeStage1[]) {\n    const withBoundingBox: MajorGraphEdgeStage2[] = edges.map((edge) => ({\n        ...edge,\n        boundingBox: pathSegmentBoundingBox(edge.seg),\n    }));\n\n    const totalBoundingBox = withBoundingBox.reduce(\n        (acc, { boundingBox }) => mergeBoundingBoxes(acc, boundingBox),\n        null as AABB | null,\n    );\n\n    if (!totalBoundingBox) {\n        return { edges: [], totalBoundingBox: null };\n    }\n\n    const edgeTree = new QuadTree<number>(\n        totalBoundingBox,\n        INTERSECTION_TREE_DEPTH,\n    );\n\n    const splitsPerEdge: Record<number, number[]> = {};\n\n    function addSplit(i: number, t: number) {\n        if (!hasOwn(splitsPerEdge, i)) splitsPerEdge[i] = [];\n        splitsPerEdge[i].push(t);\n    }\n\n    for (let i = 0; i < withBoundingBox.length; i++) {\n        const edge = withBoundingBox[i];\n        const candidates = edgeTree.find(edge.boundingBox);\n        for (const j of candidates) {\n            const candidate = edges[j];\n            const includeEndpoints =\n                edge.parent !== candidate.parent ||\n                !(\n                    // TODO: this is not correct\n                    (\n                        vectorsEqual(\n                            getEndPoint(candidate.seg),\n                            getStartPoint(edge.seg),\n                            EPS.point,\n                        ) ||\n                        vectorsEqual(\n                            getStartPoint(candidate.seg),\n                            getEndPoint(edge.seg),\n                            EPS.point,\n                        )\n                    )\n                );\n            const intersection = pathSegmentIntersection(\n                edge.seg,\n                candidate.seg,\n                includeEndpoints,\n                EPS,\n            );\n            for (const [t0, t1] of intersection) {\n                addSplit(i, t0);\n                addSplit(j, t1);\n            }\n        }\n\n        /*\n         Insert the edge to the tree here, after checking intersections.\n         That way, each pair is only tested once.\n        */\n        edgeTree.insert(edge.boundingBox, i);\n    }\n\n    const newEdges: MajorGraphEdgeStage2[] = [];\n\n    for (let i = 0; i < withBoundingBox.length; i++) {\n        const edge = withBoundingBox[i];\n        if (!hasOwn(splitsPerEdge, i)) {\n            newEdges.push(edge);\n            continue;\n        }\n        const splits = splitsPerEdge[i];\n        splits.sort();\n        let tmpSeg = edge.seg;\n        let prevT = 0;\n        for (let j = 0; j < splits.length; j++) {\n            const t = splits[j];\n\n            if (t > 1 - EPS.param) break; // skip splits near end\n\n            const tt = (t - prevT) / (1 - prevT);\n            prevT = t;\n\n            if (tt < EPS.param) continue; // skip splits near start\n            if (tt > 1 - EPS.param) continue; // skip splits near end\n\n            const [seg1, seg2] = splitSegmentAt(tmpSeg, tt);\n            newEdges.push({\n                seg: seg1,\n                boundingBox: pathSegmentBoundingBox(seg1),\n                parent: edge.parent,\n            });\n            tmpSeg = seg2;\n        }\n        newEdges.push({\n            seg: tmpSeg,\n            boundingBox: pathSegmentBoundingBox(tmpSeg),\n            parent: edge.parent,\n        });\n    }\n\n    return { edges: newEdges, totalBoundingBox };\n}\n\nfunction findVertices(\n    edges: MajorGraphEdgeStage2[],\n    boundingBox: AABB,\n): MajorGraph {\n    const vertexTree = new QuadTree<MajorGraphVertex>(\n        boundingBox,\n        POINT_TREE_DEPTH,\n    );\n\n    const newVertices: MajorGraphVertex[] = [];\n\n    function getVertex(point: Vector): MajorGraphVertex {\n        const box = boundingBoxAroundPoint(point, EPS.point);\n        const existingVertices = vertexTree.find(box);\n        if (existingVertices.size) {\n            return firstElementOfSet(existingVertices);\n        } else {\n            const vertex: MajorGraphVertex = {\n                point,\n                outgoingEdges: [],\n            };\n            vertexTree.insert(box, vertex);\n            newVertices.push(vertex);\n            return vertex;\n        }\n    }\n\n    const getVertexId = createObjectCounter();\n    const vertexPairIdToEdges: Record<\n        string,\n        [MajorGraphEdgeStage2, MajorGraphEdge, MajorGraphEdge][]\n    > = {};\n\n    const newEdges = edges.flatMap((edge) => {\n        const startVertex = getVertex(getStartPoint(edge.seg));\n        const endVertex = getVertex(getEndPoint(edge.seg));\n\n        // discard zero-length segments\n        if (startVertex === endVertex) {\n            switch (edge.seg[0]) {\n                case \"L\":\n                    return [];\n                case \"C\":\n                    if (\n                        vectorsEqual(edge.seg[1], edge.seg[2], EPS.point) &&\n                        vectorsEqual(edge.seg[3], edge.seg[4], EPS.point)\n                    ) {\n                        return [];\n                    }\n                    break;\n                case \"Q\":\n                    if (vectorsEqual(edge.seg[1], edge.seg[2], EPS.point)) {\n                        return [];\n                    }\n                    break;\n                case \"A\":\n                    if (edge.seg[5] === false) {\n                        return [];\n                    }\n                    break;\n            }\n        }\n\n        const vertexPairId = `${getVertexId(startVertex)}:${getVertexId(endVertex)}`;\n        // TODO: check other direction\n        if (hasOwn(vertexPairIdToEdges, vertexPairId)) {\n            const existingEdge = vertexPairIdToEdges[vertexPairId].find(\n                (other) => segmentsEqual(other[0].seg, edge.seg, EPS.point),\n            );\n            if (existingEdge) {\n                existingEdge[1].parent |= edge.parent;\n                existingEdge[2].parent |= edge.parent;\n                return [];\n            }\n        }\n\n        const fwdEdge: MajorGraphEdge = {\n            ...edge,\n            incidentVertices: [startVertex, endVertex],\n            directionFlag: false,\n            twin: null,\n        };\n\n        const bwdEdge: MajorGraphEdge = {\n            ...edge,\n            incidentVertices: [endVertex, startVertex],\n            directionFlag: true,\n            twin: fwdEdge,\n        };\n\n        fwdEdge.twin = bwdEdge;\n\n        startVertex.outgoingEdges.push(fwdEdge);\n        endVertex.outgoingEdges.push(bwdEdge);\n\n        if (hasOwn(vertexPairIdToEdges, vertexPairId)) {\n            vertexPairIdToEdges[vertexPairId].push([edge, fwdEdge, bwdEdge]);\n        } else {\n            vertexPairIdToEdges[vertexPairId] = [[edge, fwdEdge, bwdEdge]];\n        }\n\n        return [fwdEdge, bwdEdge];\n    });\n\n    return {\n        edges: newEdges,\n        vertices: newVertices,\n    };\n}\n\nfunction getOrder(vertex: MajorGraphVertex | MinorGraphVertex) {\n    return vertex.outgoingEdges.length;\n}\n\nfunction computeMinor({ vertices }: MajorGraph): MinorGraph {\n    const newEdges: MinorGraphEdge[] = [];\n    const newVertices: MinorGraphVertex[] = [];\n\n    const toMinorVertex = memoizeWeak((_majorVertex: MajorGraphVertex) => {\n        const minorVertex: MinorGraphVertex = { outgoingEdges: [] };\n        newVertices.push(minorVertex);\n        return minorVertex;\n    }) as (majorVertex: MajorGraphVertex) => MinorGraphVertex;\n\n    const getEdgeId = createObjectCounter();\n    const idToEdge: Record<string, MinorGraphEdge> = {};\n    const visited = new WeakSet<MajorGraphVertex>();\n\n    // first handle components that are not cycles\n    for (const vertex of vertices) {\n        if (getOrder(vertex) === 2) continue;\n\n        const startVertex = toMinorVertex(vertex);\n\n        for (const startEdge of vertex.outgoingEdges) {\n            const segments: PathSegment[] = [];\n            let edge = startEdge;\n            while (\n                edge.parent === startEdge.parent &&\n                edge.directionFlag === startEdge.directionFlag &&\n                getOrder(edge.incidentVertices[1]) === 2\n            ) {\n                segments.push(edge.seg);\n                visited.add(edge.incidentVertices[1]);\n                const [edge1, edge2] = edge.incidentVertices[1].outgoingEdges;\n                assertCondition(\n                    edge1.twin === edge || edge2.twin === edge,\n                    \"Wrong twin structure.\",\n                );\n                edge = edge1.twin === edge ? edge2 : edge1; // choose the one we didn't use to come here\n            }\n            segments.push(edge.seg);\n            const endVertex = toMinorVertex(edge.incidentVertices[1]);\n            assertDefined(edge.twin, \"Edge doesn't have a twin.\");\n            assertDefined(startEdge.twin, \"Edge doesn't have a twin.\");\n            const edgeId = `${getEdgeId(startEdge)}-${getEdgeId(edge)}`;\n            const twinId = `${getEdgeId(edge.twin)}-${getEdgeId(startEdge.twin)}`;\n            const twin = idToEdge[twinId] ?? null;\n            const newEdge: MinorGraphEdge = {\n                segments,\n                parent: startEdge.parent,\n                incidentVertices: [startVertex, endVertex],\n                directionFlag: startEdge.directionFlag,\n                twin: twin,\n            };\n            if (twin) {\n                twin.twin = newEdge;\n            }\n            idToEdge[edgeId] = newEdge;\n            startVertex.outgoingEdges.push(newEdge);\n            newEdges.push(newEdge);\n        }\n    }\n\n    // handle cyclic components\n    const cycles: MinorGraphCycle[] = [];\n    for (const vertex of vertices) {\n        if (getOrder(vertex) !== 2 || visited.has(vertex)) continue;\n        let edge = vertex.outgoingEdges[0];\n        const cycle: MinorGraphCycle = {\n            segments: [],\n            parent: edge.parent,\n            directionFlag: edge.directionFlag,\n        };\n        do {\n            cycle.segments.push(edge.seg);\n            visited.add(edge.incidentVertices[0]);\n            assertEqual(\n                getOrder(edge.incidentVertices[1]),\n                2,\n                \"Found an unvisited vertex of order != 2.\",\n            );\n            const [edge1, edge2] = edge.incidentVertices[1].outgoingEdges;\n            assertCondition(\n                edge1.twin === edge || edge2.twin === edge,\n                \"Wrong twin structure.\",\n            );\n            edge = edge1.twin === edge ? edge2 : edge1;\n        } while (edge.incidentVertices[0] !== vertex);\n        cycles.push(cycle);\n    }\n\n    return {\n        edges: newEdges,\n        vertices: newVertices,\n        cycles,\n    };\n}\n\nfunction removeDanglingEdges(graph: MinorGraph) {\n    function walk(parent: 1 | 2) {\n        const keptVertices = new WeakSet<MinorGraphVertex>();\n        const vertexToLevel = new WeakMap<MinorGraphVertex, number>();\n\n        function visit(\n            vertex: MinorGraphVertex,\n            incomingEdge: MinorGraphEdge | null,\n            level: number,\n        ): number {\n            if (vertexToLevel.has(vertex)) {\n                return vertexToLevel.get(vertex)!;\n            }\n            vertexToLevel.set(vertex, level);\n\n            let minLevel = Infinity;\n            for (const edge of vertex.outgoingEdges) {\n                if (edge.parent & parent && edge !== incomingEdge) {\n                    minLevel = Math.min(\n                        minLevel,\n                        visit(edge.incidentVertices[1], edge.twin, level + 1),\n                    );\n                }\n            }\n\n            if (minLevel <= level) {\n                keptVertices.add(vertex);\n            }\n\n            return minLevel;\n        }\n\n        for (const edge of graph.edges) {\n            if (edge.parent & parent) {\n                visit(edge.incidentVertices[0], null, 0);\n            }\n        }\n\n        return keptVertices;\n    }\n\n    const keptVerticesA = walk(1);\n    const keptVerticesB = walk(2);\n\n    function keepVertex(vertex: MinorGraphVertex): boolean {\n        return keptVerticesA.has(vertex) || keptVerticesB.has(vertex);\n    }\n\n    function keepEdge(edge: MinorGraphEdge): boolean {\n        return (\n            ((edge.parent & 1) === 1 &&\n                keptVerticesA.has(edge.incidentVertices[0]) &&\n                keptVerticesA.has(edge.incidentVertices[1])) ||\n            ((edge.parent & 2) === 2 &&\n                keptVerticesB.has(edge.incidentVertices[0]) &&\n                keptVerticesB.has(edge.incidentVertices[1]))\n        );\n    }\n\n    graph.vertices = graph.vertices.filter(keepVertex);\n\n    for (const vertex of graph.vertices) {\n        vertex.outgoingEdges = vertex.outgoingEdges.filter(keepEdge);\n    }\n\n    graph.edges = graph.edges.filter(keepEdge);\n}\n\nfunction getIncidenceAngle({ directionFlag, segments }: MinorGraphEdge) {\n    let p0: Vector;\n    let p1: Vector;\n\n    const seg = segments[0]; // TODO: explain in comment why this is always the incident one in both fwd and bwd\n\n    if (!directionFlag) {\n        p0 = samplePathSegmentAt(seg, 0);\n        p1 = samplePathSegmentAt(seg, EPS.param);\n    } else {\n        p0 = samplePathSegmentAt(seg, 1);\n        p1 = samplePathSegmentAt(seg, 1 - EPS.param);\n    }\n\n    return Math.atan2(p1[1] - p0[1], p1[0] - p0[0]);\n}\n\nfunction sortOutgoingEdgesByAngle({ vertices }: MinorGraph) {\n    // TODO: this will hardly be a bottleneck, but profile whether memoization\n    //  actually helps and maybe use a simpler function that's monotonic\n    //  in angle.\n\n    const getAngle = memoizeWeak(getIncidenceAngle);\n\n    for (const vertex of vertices) {\n        if (getOrder(vertex) > 2) {\n            vertex.outgoingEdges.sort((a, b) => getAngle(a) - getAngle(b));\n        }\n    }\n}\n\nfunction getNextEdge(edge: MinorGraphEdge) {\n    const { outgoingEdges } = edge.incidentVertices[1];\n    const index = outgoingEdges.findIndex((other) => other.twin === edge);\n    return outgoingEdges[(index + 1) % outgoingEdges.length];\n}\n\nconst faceToPolygon = memoizeWeak((face: DualGraphVertex) =>\n    face.incidentEdges.flatMap((edge): Vector[] => {\n        const CNT = 3;\n\n        const points: Vector[] = [];\n\n        for (const seg of edge.segments) {\n            for (let i = 0; i < CNT; i++) {\n                const t0 = i / CNT;\n                const t = edge.directionFlag ? 1 - t0 : t0;\n                points.push(samplePathSegmentAt(seg, t));\n            }\n        }\n\n        return points;\n    }),\n);\n\nfunction intervalCrossesPoint(a: number, b: number, p: number) {\n    /*\n     This deserves its own routine because of the following trick.\n     We use different inequalities here to make sure we only count one of\n     two intervals that meet precisely at p.\n    */\n    const dy1 = a >= p;\n    const dy2 = b < p;\n    return dy1 === dy2;\n}\n\nfunction lineSegmentIntersectsHorizontalRay(\n    a: Vector,\n    b: Vector,\n    point: Vector,\n): boolean {\n    if (!intervalCrossesPoint(a[1], b[1], point[1])) return false;\n    const x = linMap(point[1], a[1], b[1], a[0], b[0]);\n    return x >= point[0];\n}\n\nfunction computePointWinding(polygon: Vector[], testedPoint: Vector) {\n    if (polygon.length <= 2) return 0;\n    let prevPoint = polygon[polygon.length - 1];\n    let winding = 0;\n    for (const point of polygon) {\n        if (lineSegmentIntersectsHorizontalRay(prevPoint, point, testedPoint)) {\n            winding += point[1] > prevPoint[1] ? -1 : 1;\n        }\n        prevPoint = point;\n    }\n    return winding;\n}\n\nfunction computeWinding(face: DualGraphVertex) {\n    const polygon = faceToPolygon(face);\n\n    for (let i = 0; i < polygon.length; i++) {\n        const a = polygon[i];\n        const b = polygon[(i + 1) % polygon.length];\n        const c = polygon[(i + 2) % polygon.length];\n        const testedPoint: Vector = [\n            (a[0] + b[0] + c[0]) / 3,\n            (a[1] + b[1] + c[1]) / 3,\n        ];\n        const winding = computePointWinding(polygon, testedPoint);\n        if (winding !== 0) {\n            return {\n                winding,\n                point: testedPoint,\n            };\n        }\n    }\n\n    assertUnreachable(\"No ear in polygon found.\");\n}\n\nfunction computeDual({ edges, cycles }: MinorGraph): DualGraphComponent[] {\n    const newVertices: DualGraphVertex[] = [];\n\n    const minorToDualEdge = new WeakMap<MinorGraphEdge, DualGraphHalfEdge>();\n    for (const startEdge of edges) {\n        if (minorToDualEdge.has(startEdge)) continue;\n        const face: DualGraphVertex = {\n            incidentEdges: [],\n            flag: 0,\n        };\n        let edge = startEdge;\n        do {\n            assertDefined(edge.twin, \"Edge doesn't have a twin\");\n            const twin = minorToDualEdge.get(edge.twin) ?? null;\n            const newEdge = {\n                segments: edge.segments,\n                parent: edge.parent,\n                incidentVertex: face,\n                directionFlag: edge.directionFlag,\n                twin,\n            };\n            if (twin) {\n                twin.twin = newEdge;\n            }\n            minorToDualEdge.set(edge, newEdge);\n            face.incidentEdges.push(newEdge);\n            edge = getNextEdge(edge);\n        } while (edge.incidentVertices[0] !== startEdge.incidentVertices[0]);\n        newVertices.push(face);\n    }\n\n    for (const cycle of cycles) {\n        const innerFace: DualGraphVertex = {\n            incidentEdges: [],\n            flag: 0,\n        };\n\n        const innerHalfEdge: DualGraphHalfEdge = {\n            segments: cycle.segments,\n            parent: cycle.parent,\n            incidentVertex: innerFace,\n            directionFlag: cycle.directionFlag,\n            twin: null,\n        };\n\n        const outerFace: DualGraphVertex = {\n            incidentEdges: [],\n            flag: 0,\n        };\n\n        const outerHalfEdge: DualGraphHalfEdge = {\n            segments: [...cycle.segments].reverse(),\n            parent: cycle.parent,\n            incidentVertex: outerFace,\n            directionFlag: !cycle.directionFlag,\n            twin: innerHalfEdge,\n        };\n\n        innerHalfEdge.twin = outerHalfEdge;\n        innerFace.incidentEdges.push(innerHalfEdge);\n        outerFace.incidentEdges.push(outerHalfEdge);\n\n        newVertices.push(innerFace, outerFace);\n    }\n\n    const components: DualGraphComponent[] = [];\n\n    const visitedVertices = new WeakSet<DualGraphVertex>();\n    const visitedEdges = new WeakSet<DualGraphHalfEdge>();\n    for (const vertex of newVertices) {\n        if (visitedVertices.has(vertex)) continue;\n        const componentVertices: DualGraphVertex[] = [];\n        const componentEdges: DualGraphHalfEdge[] = [];\n        const visit = (vertex: DualGraphVertex) => {\n            if (!visitedVertices.has(vertex)) {\n                componentVertices.push(vertex);\n            }\n            visitedVertices.add(vertex);\n            for (const edge of vertex.incidentEdges) {\n                if (visitedEdges.has(edge)) {\n                    continue;\n                }\n                const { twin } = edge;\n                assertDefined(twin, \"Edge doesn't have a twin.\");\n                componentEdges.push(edge, twin);\n                visitedEdges.add(edge);\n                visitedEdges.add(twin);\n                visit(twin.incidentVertex);\n            }\n        };\n        visit(vertex);\n        const outerFace = componentVertices.find(\n            (face) => computeWinding(face).winding < 0,\n        );\n        assertDefined(outerFace, \"No outer face of a component found.\");\n        assertEqual(\n            countIf(\n                componentVertices,\n                (face) => computeWinding(face).winding < 0,\n            ),\n            1,\n            \"Multiple outer faces found.\",\n        );\n        components.push({\n            vertices: componentVertices,\n            edges: componentEdges,\n            outerFace,\n        });\n    }\n\n    return components;\n}\n\nfunction boundingBoxIntersectsHorizontalRay(\n    boundingBox: AABB,\n    point: Vector,\n): boolean {\n    return (\n        intervalCrossesPoint(boundingBox.top, boundingBox.bottom, point[1]) &&\n        boundingBox.right >= point[0]\n    );\n}\n\nfunction pathSegmentHorizontalRayIntersectionCount(\n    origSeg: PathSegment,\n    point: Vector,\n): number {\n    type IntersectionSegment = { boundingBox: AABB; seg: PathSegment };\n    const totalBoundingBox = pathSegmentBoundingBox(origSeg);\n    if (!boundingBoxIntersectsHorizontalRay(totalBoundingBox, point)) return 0;\n    let segments: IntersectionSegment[] = [\n        { boundingBox: totalBoundingBox, seg: origSeg },\n    ];\n    let count = 0;\n    while (segments.length > 0) {\n        const nextSegments: IntersectionSegment[] = [];\n        for (const { boundingBox, seg } of segments) {\n            if (boundingBoxMaxExtent(boundingBox) < EPS.linear) {\n                if (\n                    lineSegmentIntersectsHorizontalRay(\n                        getStartPoint(seg),\n                        getEndPoint(seg),\n                        point,\n                    )\n                ) {\n                    count++;\n                }\n            } else {\n                const split = splitSegmentAt(seg, 0.5);\n                const boundingBox0 = pathSegmentBoundingBox(split[0]);\n                if (boundingBoxIntersectsHorizontalRay(boundingBox0, point)) {\n                    nextSegments.push({\n                        boundingBox: boundingBox0,\n                        seg: split[0],\n                    });\n                }\n                const boundingBox1 = pathSegmentBoundingBox(split[1]);\n                if (boundingBoxIntersectsHorizontalRay(boundingBox1, point)) {\n                    nextSegments.push({\n                        boundingBox: boundingBox1,\n                        seg: split[1],\n                    });\n                }\n            }\n        }\n        segments = nextSegments;\n    }\n    return count;\n}\n\nfunction testInclusion(a: DualGraphComponent, b: DualGraphComponent) {\n    // TODO: Intersection counting will fail if a curve touches the horizontal line but doesn't go through.\n    const testedPoint = getStartPoint(a.edges[0].segments[0]);\n    for (const face of b.vertices) {\n        if (face === b.outerFace) continue;\n        let count = 0;\n        for (const edge of face.incidentEdges) {\n            for (const seg of edge.segments) {\n                count += pathSegmentHorizontalRayIntersectionCount(\n                    seg,\n                    testedPoint,\n                );\n            }\n        }\n\n        if (count % 2 === 1) return face;\n    }\n    return null;\n}\n\nfunction computeNestingTree(components: DualGraphComponent[]): NestingTree[] {\n    let nestingTrees: NestingTree[] = [];\n\n    function insert(trees: NestingTree[], component: DualGraphComponent) {\n        let found = false;\n        for (const tree of trees) {\n            const face = testInclusion(component, tree.component);\n            if (face) {\n                if (tree.outgoingEdges.has(face)) {\n                    const children = tree.outgoingEdges.get(face)!;\n                    tree.outgoingEdges.set(face, insert(children, component));\n                } else {\n                    tree.outgoingEdges.set(face, [\n                        { component, outgoingEdges: new Map() },\n                    ]);\n                }\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            return trees;\n        } else {\n            const newTree: NestingTree = {\n                component,\n                outgoingEdges: new Map(),\n            };\n            const newTrees: NestingTree[] = [newTree];\n            for (const tree of trees) {\n                const face = testInclusion(tree.component, component);\n                if (face) {\n                    if (newTree.outgoingEdges.has(face)) {\n                        newTree.outgoingEdges.get(face)!.push(tree);\n                    } else {\n                        newTree.outgoingEdges.set(face, [tree]);\n                    }\n                } else {\n                    newTrees.push(tree);\n                }\n            }\n            return newTrees;\n        }\n    }\n\n    for (const component of components) {\n        nestingTrees = insert(nestingTrees, component);\n    }\n\n    return nestingTrees;\n}\n\nfunction getFlag(count: number, fillRule: FillRule) {\n    switch (fillRule) {\n        case FillRule.NonZero:\n            return count === 0 ? 0 : 1;\n        case FillRule.EvenOdd:\n            return count % 2 === 0 ? 0 : 1;\n    }\n}\n\nfunction flagFaces(\n    nestingTrees: NestingTree[],\n    aFillRule: FillRule,\n    bFillRule: FillRule,\n) {\n    function visitTree(\n        tree: NestingTree,\n        aRunningCount: number,\n        bRunningCount: number,\n    ) {\n        const visitedFaces = new WeakSet<DualGraphVertex>();\n\n        function visitFace(\n            face: DualGraphVertex,\n            aRunningCount: number,\n            bRunningCount: number,\n        ) {\n            if (visitedFaces.has(face)) return;\n            visitedFaces.add(face);\n            const aFlag = getFlag(aRunningCount, aFillRule);\n            const bFlag = getFlag(bRunningCount, bFillRule);\n            face.flag = aFlag | (bFlag << 1);\n            for (const edge of face.incidentEdges) {\n                const twin = edge.twin;\n                assertDefined(twin, \"Edge doesn't have a twin.\");\n                let nextACount = aRunningCount;\n                if (edge.parent & 1) {\n                    nextACount += edge.directionFlag ? -1 : 1;\n                }\n                let nextBCount = bRunningCount;\n                if (edge.parent & 2) {\n                    nextBCount += edge.directionFlag ? -1 : 1;\n                }\n                visitFace(twin.incidentVertex, nextACount, nextBCount);\n            }\n            if (tree.outgoingEdges.has(face)) {\n                const subtrees = tree.outgoingEdges.get(face)!;\n                for (const subtree of subtrees) {\n                    visitTree(subtree, aRunningCount, bRunningCount);\n                }\n            }\n        }\n\n        assertDefined(\n            tree.component.outerFace,\n            \"Component doesn't have an outer face.\",\n        );\n\n        visitFace(tree.component.outerFace, aRunningCount, bRunningCount);\n    }\n\n    for (const tree of nestingTrees) {\n        visitTree(tree, 0, 0);\n    }\n}\n\nfunction* getSelectedFaces(\n    nestingTrees: NestingTree[],\n    predicate: (face: DualGraphVertex) => boolean,\n): Iterable<DualGraphVertex> {\n    function* visit(tree: NestingTree): Iterable<DualGraphVertex> {\n        for (const face of tree.component.vertices) {\n            if (predicate(face)) {\n                yield face;\n            }\n        }\n        for (const subtrees of tree.outgoingEdges.values()) {\n            for (const subtree of subtrees) {\n                yield* visit(subtree);\n            }\n        }\n    }\n\n    for (const tree of nestingTrees) {\n        yield* visit(tree);\n    }\n}\n\nfunction* walkFaces(faces: Set<DualGraphVertex>) {\n    function isRemovedEdge(edge: DualGraphHalfEdge) {\n        assertDefined(edge.twin, \"Edge doesn't have a twin.\");\n        return (\n            faces.has(edge.incidentVertex) ===\n            faces.has(edge.twin.incidentVertex)\n        );\n    }\n\n    const edgeToNext = new WeakMap<DualGraphHalfEdge, DualGraphHalfEdge>();\n    for (const face of faces) {\n        let prevEdge = face.incidentEdges[face.incidentEdges.length - 1];\n        for (const edge of face.incidentEdges) {\n            edgeToNext.set(prevEdge, edge);\n            prevEdge = edge;\n        }\n    }\n\n    const visitedEdges = new WeakSet<DualGraphHalfEdge>();\n    for (const face of faces) {\n        for (const startEdge of face.incidentEdges) {\n            if (isRemovedEdge(startEdge) || visitedEdges.has(startEdge)) {\n                continue;\n            }\n            let edge = startEdge;\n            do {\n                if (edge.directionFlag) {\n                    yield* map(edge.segments, reversePathSegment);\n                } else {\n                    yield* edge.segments;\n                }\n                visitedEdges.add(edge);\n                edge = edgeToNext.get(edge)!;\n                while (isRemovedEdge(edge)) {\n                    assertDefined(edge.twin, \"Edge doesn't have a twin.\");\n                    edge = edgeToNext.get(edge.twin)!;\n                }\n            } while (edge !== startEdge);\n        }\n    }\n}\n\nfunction dumpFaces(\n    nestingTrees: NestingTree[],\n    predicate: (face: DualGraphVertex) => boolean,\n): Path[] {\n    const paths: Path[] = [];\n\n    function visit(tree: NestingTree) {\n        for (const face of tree.component.vertices) {\n            if (!predicate(face) || face === tree.component.outerFace) {\n                continue;\n            }\n\n            const path: Path = [];\n\n            for (const edge of face.incidentEdges) {\n                if (edge.directionFlag) {\n                    path.push(...edge.segments.map(reversePathSegment));\n                } else {\n                    path.push(...edge.segments);\n                }\n            }\n\n            // poke holes in the face\n            if (tree.outgoingEdges.has(face)) {\n                for (const subtree of tree.outgoingEdges.get(face)!) {\n                    const { outerFace } = subtree.component;\n\n                    assertDefined(outerFace, \"Component has no outer face.\");\n\n                    for (const edge of outerFace.incidentEdges) {\n                        if (edge.directionFlag) {\n                            path.push(...edge.segments.map(reversePathSegment));\n                        } else {\n                            path.push(...edge.segments);\n                        }\n                    }\n                }\n            }\n\n            paths.push(path);\n        }\n\n        for (const subtrees of tree.outgoingEdges.values()) {\n            for (const subtree of subtrees) {\n                visit(subtree);\n            }\n        }\n    }\n\n    for (const tree of nestingTrees) {\n        visit(tree);\n    }\n\n    return paths;\n}\n\nfunction majorGraphToDot({ vertices, edges }: MajorGraph) {\n    const toNumber = createObjectCounter();\n    return `digraph {\n${vertices.map((v) => `  ${toNumber(v)} [label=\"${v.point.join(\", \")}\"]`).join(\"\\n\")}\n${edges.map((edge) => \"  \" + edge.incidentVertices.map(toNumber).join(\" -> \")).join(\"\\n\")}\n}\n`;\n}\n\nfunction minorGraphToDot(edges: MinorGraphEdge[]) {\n    const toNumber = createObjectCounter();\n    return `digraph {\n${edges.map((edge) => \"  \" + edge.incidentVertices.map(toNumber).join(\" -> \")).join(\"\\n\")}\n}\n`;\n}\n\nfunction dualGraphToDot(components: DualGraphComponent[]) {\n    const toNumber = createObjectCounter();\n    return `strict graph {\n${components.map(({ edges }) => edges.map((edge) => `  ${toNumber(edge.incidentVertex)} -- ${toNumber(edge.twin!.incidentVertex)}`).join(\"\\n\")).join(\"\\n\")}\n}\n`;\n}\n\nfunction nestingTreesToDot(trees: NestingTree[]) {\n    const toNumber = createObjectCounter();\n    let out = \"digraph {\\n\";\n\n    function visit(tree: NestingTree) {\n        for (const edges of tree.outgoingEdges.values()) {\n            for (const subtree of edges) {\n                out += `  ${toNumber(tree.component)} -> ${toNumber(subtree.component)}\\n`;\n                visit(subtree);\n            }\n        }\n    }\n\n    trees.forEach(visit);\n\n    return out + \"}\\n\";\n}\n\nconst operationPredicates: Record<\n    PathBooleanOperation,\n    (face: DualGraphVertex) => boolean\n> = {\n    [PathBooleanOperation.Union]: ({ flag }) => flag > 0,\n    [PathBooleanOperation.Difference]: ({ flag }) => flag === 1,\n    [PathBooleanOperation.Intersection]: ({ flag }) => flag === 3,\n    [PathBooleanOperation.Exclusion]: ({ flag }) => flag === 1 || flag === 2,\n    [PathBooleanOperation.Division]: ({ flag }) => (flag & 1) === 1,\n    [PathBooleanOperation.Fracture]: ({ flag }) => flag > 0,\n};\n\nexport function pathBoolean(\n    a: Path,\n    aFillRule: FillRule,\n    b: Path,\n    bFillRule: FillRule,\n    op: PathBooleanOperation,\n): Path[] {\n    const unsplitEdges = [\n        ...map(a, segmentToEdge(1)),\n        ...map(b, segmentToEdge(2)),\n    ];\n\n    splitAtSelfIntersections(unsplitEdges);\n\n    const { edges: splitEdges, totalBoundingBox } =\n        splitAtIntersections(unsplitEdges);\n\n    if (!totalBoundingBox) {\n        // input geometry is empty\n        return [];\n    }\n\n    const majorGraph = findVertices(splitEdges, totalBoundingBox);\n    // console.log(majorGraphToDot(majorGraph));\n\n    const minorGraph = computeMinor(majorGraph);\n    // console.log(minorGraphToDot(minorGraph.edges));\n    // console.dir(minorGraph.cycles, { depth: 4 });\n\n    removeDanglingEdges(minorGraph);\n    // console.log(minorGraphToDot(minorGraph.edges));\n\n    sortOutgoingEdgesByAngle(minorGraph);\n\n    const dualGraphComponents = computeDual(minorGraph);\n    // console.log(dualGraphToDot(dualGraphComponents));\n\n    const nestingTrees = computeNestingTree(dualGraphComponents);\n    // console.log(nestingTrees.length, nestingTreesToDot(nestingTrees));\n\n    flagFaces(nestingTrees, aFillRule, bFillRule);\n\n    const predicate = operationPredicates[op];\n\n    switch (op) {\n        case PathBooleanOperation.Division:\n        case PathBooleanOperation.Fracture:\n            return dumpFaces(nestingTrees, predicate);\n        default: {\n            const selectedFaces = new Set(\n                getSelectedFaces(nestingTrees, predicate),\n            );\n            return [[...walkFaces(selectedFaces)]];\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Vector } from \"./Vector\";\n\nexport type AbsolutePathCommand =\n    | [\"M\", Vector]\n    | [\"L\", Vector]\n    | [\"C\", Vector, Vector, Vector]\n    | [\"S\", Vector, Vector]\n    | [\"Q\", Vector, Vector]\n    | [\"T\", Vector]\n    | [\"A\", number, number, number, boolean, boolean, Vector]\n    | [\"Z\"]\n    | [\"z\"];\n\ntype RelativePathCommand =\n    | [\"H\", number]\n    | [\"V\", number]\n    | [\"m\", number, number]\n    | [\"l\", number, number]\n    | [\"h\", number]\n    | [\"v\", number]\n    | [\"c\", number, number, number, number, number, number]\n    | [\"s\", number, number, number, number]\n    | [\"q\", number, number, number, number]\n    | [\"t\", number, number]\n    | [\"a\", number, number, number, boolean, boolean, number, number];\n\nexport type PathCommand = AbsolutePathCommand | RelativePathCommand;\n\nexport function* toAbsoluteCommands(\n    commands: Iterable<PathCommand>,\n): Iterable<AbsolutePathCommand> {\n    let lastPoint: Vector = [0, 0];\n    let firstPoint = lastPoint;\n\n    for (const cmd of commands) {\n        switch (cmd[0]) {\n            case \"M\":\n                yield cmd;\n                lastPoint = firstPoint = cmd[1];\n                break;\n            case \"L\":\n                yield cmd;\n                lastPoint = cmd[1];\n                break;\n            case \"C\":\n                yield cmd;\n                lastPoint = cmd[3];\n                break;\n            case \"S\":\n                yield cmd;\n                lastPoint = cmd[2];\n                break;\n            case \"Q\":\n                yield cmd;\n                lastPoint = cmd[2];\n                break;\n            case \"T\":\n                yield cmd;\n                lastPoint = cmd[1];\n                break;\n            case \"A\":\n                yield cmd;\n                lastPoint = cmd[6];\n                break;\n            case \"Z\":\n            case \"z\":\n                lastPoint = firstPoint;\n                yield [\"Z\"];\n                break;\n            case \"H\":\n                lastPoint = [cmd[1], lastPoint[1]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"V\":\n                lastPoint = [lastPoint[0], cmd[1]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"m\":\n                lastPoint = firstPoint = [\n                    lastPoint[0] + cmd[1],\n                    lastPoint[1] + cmd[2],\n                ];\n                yield [\"M\", lastPoint];\n                break;\n            case \"l\":\n                lastPoint = [lastPoint[0] + cmd[1], lastPoint[1] + cmd[2]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"h\":\n                lastPoint = [lastPoint[0] + cmd[1], lastPoint[1]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"v\":\n                lastPoint = [lastPoint[0], lastPoint[1] + cmd[1]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"c\":\n                yield [\n                    \"C\",\n                    [lastPoint[0] + cmd[1], lastPoint[1] + cmd[2]],\n                    [lastPoint[0] + cmd[3], lastPoint[1] + cmd[4]],\n                    (lastPoint = [\n                        lastPoint[0] + cmd[5],\n                        lastPoint[1] + cmd[6],\n                    ]),\n                ];\n                break;\n            case \"s\":\n                yield [\n                    \"S\",\n                    [lastPoint[0] + cmd[1], lastPoint[1] + cmd[2]],\n                    (lastPoint = [\n                        lastPoint[0] + cmd[3],\n                        lastPoint[1] + cmd[4],\n                    ]),\n                ];\n                break;\n            case \"q\":\n                yield [\n                    \"Q\",\n                    [lastPoint[0] + cmd[1], lastPoint[1] + cmd[2]],\n                    (lastPoint = [\n                        lastPoint[0] + cmd[3],\n                        lastPoint[1] + cmd[4],\n                    ]),\n                ];\n                break;\n            case \"t\":\n                yield [\n                    \"T\",\n                    (lastPoint = [\n                        lastPoint[0] + cmd[1],\n                        lastPoint[1] + cmd[2],\n                    ]),\n                ];\n                break;\n            case \"a\":\n                yield [\n                    \"A\",\n                    cmd[1],\n                    cmd[2],\n                    cmd[3],\n                    cmd[4],\n                    cmd[5],\n                    (lastPoint = [\n                        lastPoint[0] + cmd[6],\n                        lastPoint[1] + cmd[7],\n                    ]),\n                ];\n                break;\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { PathCommand, toAbsoluteCommands } from \"./PathCommand\";\nimport { PathSegment } from \"./PathSegment\";\nimport { Vector, vectorsEqual } from \"./Vector\";\n\nexport type Path = PathSegment[];\n\nfunction reflectControlPoint(point: Vector, controlPoint: Vector): Vector {\n    return [2 * point[0] - controlPoint[0], 2 * point[1] - controlPoint[1]];\n}\n\nexport function* pathFromCommands(\n    commands: Iterable<PathCommand>,\n): Iterable<PathSegment> {\n    let firstPoint: Vector | null = null;\n    let lastPoint: Vector | null = null;\n    let lastControlPoint: Vector | null = null;\n\n    function badSequence(): never {\n        throw new Error(\"Bad SVG path data sequence.\");\n    }\n\n    for (const cmd of toAbsoluteCommands(commands)) {\n        switch (cmd[0]) {\n            case \"M\":\n                lastPoint = firstPoint = cmd[1];\n                lastControlPoint = null;\n                break;\n            case \"L\":\n                if (!lastPoint) badSequence();\n                yield [\"L\", lastPoint, cmd[1]];\n                lastPoint = cmd[1];\n                lastControlPoint = null;\n                break;\n            case \"C\":\n                if (!lastPoint) badSequence();\n                yield [\"C\", lastPoint, cmd[1], cmd[2], cmd[3]];\n                lastPoint = cmd[3];\n                lastControlPoint = cmd[2];\n                break;\n            case \"S\":\n                if (!lastPoint) badSequence();\n                if (!lastControlPoint) badSequence(); // TODO: really?\n                yield [\n                    \"C\",\n                    lastPoint,\n                    reflectControlPoint(lastPoint, lastControlPoint),\n                    cmd[1],\n                    cmd[2],\n                ];\n                lastPoint = cmd[2];\n                lastControlPoint = cmd[1];\n                break;\n            case \"Q\":\n                if (!lastPoint) badSequence();\n                yield [\"Q\", lastPoint, cmd[1], cmd[2]];\n                lastPoint = cmd[2];\n                lastControlPoint = cmd[1];\n                break;\n            case \"T\":\n                if (!lastPoint) badSequence();\n                if (!lastControlPoint) badSequence(); // TODO: really?\n                lastControlPoint = reflectControlPoint(\n                    lastPoint,\n                    lastControlPoint,\n                );\n                yield [\"Q\", lastPoint, lastControlPoint, cmd[1]];\n                lastPoint = cmd[1];\n                break;\n            case \"A\":\n                if (!lastPoint) badSequence();\n                yield [\n                    \"A\",\n                    lastPoint,\n                    cmd[1],\n                    cmd[2],\n                    cmd[3],\n                    cmd[4],\n                    cmd[5],\n                    cmd[6],\n                ];\n                lastPoint = cmd[6];\n                lastControlPoint = null;\n                break;\n            case \"Z\":\n            case \"z\":\n                if (!lastPoint) badSequence();\n                if (!firstPoint) badSequence(); // TODO: really?\n                yield [\"L\", lastPoint, firstPoint];\n                lastPoint = firstPoint;\n                lastControlPoint = null;\n                break;\n        }\n    }\n}\n\nexport function* pathToCommands(\n    segments: Iterable<PathSegment>,\n    eps: number = 1e-4,\n): Iterable<PathCommand> {\n    let lastPoint: Vector | null = null;\n    for (const seg of segments) {\n        if (!lastPoint || !vectorsEqual(seg[1], lastPoint, eps)) {\n            yield [\"M\", seg[1]];\n        }\n\n        switch (seg[0]) {\n            case \"L\":\n                yield [\"L\", (lastPoint = seg[2])];\n                break;\n            case \"C\":\n                yield [\"C\", seg[2], seg[3], (lastPoint = seg[4])];\n                break;\n            case \"Q\":\n                yield [\"Q\", seg[2], (lastPoint = seg[3])];\n                break;\n            case \"A\":\n                yield [\n                    \"A\",\n                    seg[2],\n                    seg[3],\n                    seg[4],\n                    seg[5],\n                    seg[6],\n                    (lastPoint = seg[7]),\n                ];\n                break;\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Path, pathFromCommands, pathToCommands } from \"./primitives/Path\";\nimport { PathCommand } from \"./primitives/PathCommand\";\nimport { Vector } from \"./primitives/Vector\";\nimport { isBoolean, isNumber, isString } from \"./util/generic\";\nimport { map } from \"./util/iterators\";\n\nconst eof = Symbol();\n\nexport function* commandsFromPathData(d: string): Iterable<PathCommand> {\n    const reFloat = /\\s*,?\\s*(-?\\d*(?:\\d\\.|\\.\\d|\\d)\\d*(?:[eE][+\\-]?\\d+)?)/y;\n    const reCmd = /\\s*([MLCSQTAZHVmlhvcsqtaz])/y;\n    const reBool = /\\s*,?\\s*([01])/y;\n\n    let i = 0;\n\n    let lastCmd = \"M\";\n\n    function getCmd() {\n        if (i >= d.length - 1) return eof;\n\n        reCmd.lastIndex = i;\n        const match = reCmd.exec(d);\n\n        // https://razrfalcon.github.io/notes-on-svg-parsing/path-data.html#implicit-sequential-moveto-commands\n        if (!match) {\n            switch (lastCmd) {\n                case \"M\":\n                    return \"L\";\n                case \"m\":\n                    return \"l\";\n                default:\n                    return lastCmd;\n            }\n        }\n\n        i = reCmd.lastIndex;\n        return match[1];\n    }\n\n    function getFloat() {\n        reFloat.lastIndex = i;\n        const match = reFloat.exec(d);\n\n        if (!match) {\n            throw new Error(\n                `Invalid path data. Expected a number at index ${i}.`,\n            );\n        }\n\n        i = reFloat.lastIndex;\n        return Number(match[1]);\n    }\n\n    function getBool() {\n        reBool.lastIndex = i;\n        const match = reBool.exec(d);\n\n        if (!match) {\n            throw new Error(\n                `Invalid path data. Expected a flag at index ${i}.`,\n            );\n        }\n\n        i = reBool.lastIndex;\n        return match[1] === \"1\";\n    }\n\n    while (true) {\n        const cmd = getCmd();\n\n        switch (cmd) {\n            case \"M\":\n                yield [(lastCmd = \"M\"), [getFloat(), getFloat()]];\n                break;\n            case \"L\":\n                yield [(lastCmd = \"L\"), [getFloat(), getFloat()]];\n                break;\n            case \"C\":\n                yield [\n                    (lastCmd = \"C\"),\n                    [getFloat(), getFloat()],\n                    [getFloat(), getFloat()],\n                    [getFloat(), getFloat()],\n                ];\n                break;\n            case \"S\":\n                yield [\n                    (lastCmd = \"S\"),\n                    [getFloat(), getFloat()],\n                    [getFloat(), getFloat()],\n                ];\n                break;\n            case \"Q\":\n                yield [\n                    (lastCmd = \"Q\"),\n                    [getFloat(), getFloat()],\n                    [getFloat(), getFloat()],\n                ];\n                break;\n            case \"T\":\n                yield [(lastCmd = \"T\"), [getFloat(), getFloat()]];\n                break;\n            case \"A\":\n                yield [\n                    (lastCmd = \"A\"),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                    getBool(),\n                    getBool(),\n                    [getFloat(), getFloat()],\n                ];\n                break;\n            case \"Z\":\n            case \"z\":\n                yield [(lastCmd = \"Z\")];\n                break;\n            case \"H\":\n                yield [(lastCmd = \"H\"), getFloat()];\n                break;\n            case \"V\":\n                yield [(lastCmd = \"V\"), getFloat()];\n                break;\n            case \"m\":\n                yield [(lastCmd = \"m\"), getFloat(), getFloat()];\n                break;\n            case \"l\":\n                yield [(lastCmd = \"l\"), getFloat(), getFloat()];\n                break;\n            case \"h\":\n                yield [(lastCmd = \"h\"), getFloat()];\n                break;\n            case \"v\":\n                yield [(lastCmd = \"v\"), getFloat()];\n                break;\n            case \"c\":\n                yield [\n                    (lastCmd = \"c\"),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                ];\n                break;\n            case \"s\":\n                yield [\n                    (lastCmd = \"s\"),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                ];\n                break;\n            case \"q\":\n                yield [\n                    (lastCmd = \"q\"),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                ];\n                break;\n            case \"t\":\n                yield [(lastCmd = \"t\"), getFloat(), getFloat()];\n                break;\n            case \"a\":\n                yield [\n                    (lastCmd = \"a\"),\n                    getFloat(),\n                    getFloat(),\n                    getFloat(),\n                    getBool(),\n                    getBool(),\n                    getFloat(),\n                    getFloat(),\n                ];\n                break;\n            case eof:\n                return;\n        }\n    }\n}\n\nexport function pathFromPathData(d: string): Path {\n    return [...pathFromCommands(commandsFromPathData(d))];\n}\n\nexport function pathToPathData(path: Path, eps: number = 1e-4): string {\n    function mapParam(param: string | number | boolean | Vector) {\n        if (isString(param)) return param;\n        if (isNumber(param)) return param.toFixed(12);\n        if (isBoolean(param)) return param ? \"1\" : \"0\";\n        return param.map((c) => c.toFixed(12)).join(\",\");\n    }\n\n    return [\n        ...map(pathToCommands(path, eps), (cmd) => cmd.map(mapParam).join(\" \")),\n    ].join(\" \");\n}\n"],"names":["EPS","create","glMatrix.ARRAY_TYPE","fromRotation","rotate","scale","lerp","vec2.dot","vec2.len","mat2.create","mat2.fromRotation","vec2.sub","vec2.scale","vec2.transformMat2","mat2.transpose","vec2.add","vec2.set","vec2.lerp","vec2.rotate","mat2d.create","mat2d.fromTranslation","mat2d.rotate","mat2d.scale","mat2d.fromRotation","mat2d.mul","vec2.transformMat2d"],"mappings":"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","x_google_ignoreList":[4,5,6,7]}