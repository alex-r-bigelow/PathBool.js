{"version":3,"file":"path-bool.core.umd.js","sources":["../src/intersections/line-segment-AABB.ts","../src/primitives/AABB.ts","../src/QuadTree.ts","../src/intersections/path-cubic-segment-self-intersection.ts","../node_modules/gl-matrix/esm/common.js","../node_modules/gl-matrix/esm/mat2.js","../node_modules/gl-matrix/esm/mat2d.js","../node_modules/gl-matrix/esm/vec2.js","../src/util/math.ts","../src/primitives/Vector.ts","../src/primitives/PathSegment.ts","../src/intersections/line-segment.ts","../src/intersections/path-segment.ts","../src/util/generic.ts","../src/util/iterators.ts","../src/path-boolean.ts","../src/primitives/Path.ts","../src/primitives/PathCommand.ts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { AABB } from \"../primitives/AABB\";\nimport { Vector } from \"../primitives/Vector\";\n\ntype LineSegment = [Vector, Vector];\n\n// https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm\n\nconst INSIDE = 0;\nconst LEFT = 1;\nconst RIGHT = 1 << 1;\nconst BOTTOM = 1 << 2;\nconst TOP = 1 << 3;\n\nfunction outCode(x: number, y: number, boundingBox: AABB) {\n    let code = INSIDE;\n\n    if (x < boundingBox.left) {\n        code |= LEFT;\n    } else if (x > boundingBox.right) {\n        code |= RIGHT;\n    }\n\n    if (y < boundingBox.top) {\n        code |= BOTTOM;\n    } else if (y > boundingBox.bottom) {\n        code |= TOP;\n    }\n\n    return code;\n}\n\nexport function lineSegmentAABBIntersect(seg: LineSegment, boundingBox: AABB) {\n    let [[x0, y0], [x1, y1]] = seg;\n\n    let outcode0 = outCode(x0, y0, boundingBox);\n    let outcode1 = outCode(x1, y1, boundingBox);\n\n    while (true) {\n        if (!(outcode0 | outcode1)) {\n            // bitwise OR is 0: both points inside window; trivially accept and exit loop\n            return true;\n        } else if (outcode0 & outcode1) {\n            // bitwise AND is not 0: both points share an outside zone (LEFT, RIGHT, TOP,\n            // or BOTTOM), so both must be outside window; exit loop (accept is false)\n            return false;\n        } else {\n            const { top, right, bottom, left } = boundingBox;\n\n            // failed both tests, so calculate the line segment to clip\n            // from an outside point to an intersection with clip edge\n            let x: number, y: number;\n\n            // At least one endpoint is outside the clip rectangle; pick it.\n            const outcodeOut = outcode1 > outcode0 ? outcode1 : outcode0;\n\n            // Now find the intersection point;\n            // use formulas:\n            //   slope = (y1 - y0) / (x1 - x0)\n            //   x = x0 + (1 / slope) * (ym - y0), where ym is ymin or ymax\n            //   y = y0 + slope * (xm - x0), where xm is xmin or xmax\n            // No need to worry about divide-by-zero because, in each case, the\n            // outcode bit being tested guarantees the denominator is non-zero\n\n            if (outcodeOut & TOP) {\n                // point is above the clip window\n                x = x0 + ((x1 - x0) * (bottom - y0)) / (y1 - y0);\n                y = bottom;\n            } else if (outcodeOut & BOTTOM) {\n                // point is below the clip window\n                x = x0 + ((x1 - x0) * (top - y0)) / (y1 - y0);\n                y = top;\n            } else if (outcodeOut & RIGHT) {\n                // point is to the right of clip window\n                y = y0 + ((y1 - y0) * (right - x0)) / (x1 - x0);\n                x = right;\n            } else if (outcodeOut & LEFT) {\n                // point is to the left of clip window\n                y = y0 + ((y1 - y0) * (left - x0)) / (x1 - x0);\n                x = left;\n            }\n\n            // Now we move outside point to intersection point to clip\n            // and get ready for next pass.\n            if (outcodeOut == outcode0) {\n                x0 = x!;\n                y0 = y!;\n                outcode0 = outCode(x0, y0, boundingBox);\n            } else {\n                x1 = x!;\n                y1 = y!;\n                outcode1 = outCode(x1, y1, boundingBox);\n            }\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Vector } from \"./Vector\";\n\nexport type AABB = {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n};\n\nexport function boundingBoxContainsPoint(boundingBox: AABB, point: Vector) {\n    return (\n        point[0] >= boundingBox.left &&\n        point[0] <= boundingBox.right &&\n        point[1] >= boundingBox.top &&\n        point[1] <= boundingBox.bottom\n    );\n}\n\nexport function boundingBoxesOverlap(a: AABB, b: AABB) {\n    return (\n        a.left <= b.right &&\n        b.left <= a.right &&\n        a.top <= b.bottom &&\n        b.top <= a.bottom\n    );\n}\n\nexport function mergeBoundingBoxes(a: AABB | null, b: AABB): AABB {\n    if (!a) return b;\n\n    return {\n        top: Math.min(a.top, b.top),\n        right: Math.max(a.right, b.right),\n        bottom: Math.max(a.bottom, b.bottom),\n        left: Math.min(a.left, b.left),\n    };\n}\n\nexport function extendBoundingBox(boundingBox: AABB | null, point: Vector) {\n    if (!boundingBox) {\n        return {\n            top: point[1],\n            right: point[0],\n            bottom: point[1],\n            left: point[0],\n        };\n    }\n\n    return {\n        top: Math.min(boundingBox.top, point[1]),\n        right: Math.max(boundingBox.right, point[0]),\n        bottom: Math.max(boundingBox.bottom, point[1]),\n        left: Math.min(boundingBox.left, point[0]),\n    };\n}\n\nexport function boundingBoxMaxExtent(boundingBox: AABB) {\n    return Math.max(\n        boundingBox.right - boundingBox.left,\n        boundingBox.bottom - boundingBox.top,\n    );\n}\n\nexport function boundingBoxAroundPoint(point: Vector, padding: number): AABB {\n    return {\n        top: point[1] - padding,\n        right: point[0] + padding,\n        bottom: point[1] + padding,\n        left: point[0] - padding,\n    };\n}\n\nexport function expandBoundingBox(boundingBox: AABB, padding: number): AABB {\n    return {\n        top: boundingBox.top - padding,\n        right: boundingBox.right + padding,\n        bottom: boundingBox.bottom + padding,\n        left: boundingBox.left - padding,\n    };\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { lineSegmentAABBIntersect } from \"./intersections/line-segment-AABB\";\nimport {\n    AABB,\n    boundingBoxesOverlap,\n    mergeBoundingBoxes,\n} from \"./primitives/AABB\";\nimport { Vector } from \"./primitives/Vector\";\n\ntype LineSegment = [Vector, Vector];\n\nexport class QuadTree<T> {\n    static fromPairs<T>(\n        pairs: [AABB, T][],\n        depth: number,\n        innerNodeCapacity: number = 8,\n    ): QuadTree<T> {\n        if (pairs.length === 0) {\n            throw new Error(\"QuadTree.fromPairs: at least one pair needed.\");\n        }\n\n        let boundingBox = pairs[0][0];\n        for (let i = 1; i < pairs.length; i++) {\n            boundingBox = mergeBoundingBoxes(boundingBox, pairs[i][0]);\n        }\n\n        const tree = new QuadTree<T>(boundingBox, depth, innerNodeCapacity);\n\n        for (const [key, value] of pairs) {\n            tree.insert(key, value);\n        }\n\n        return tree;\n    }\n\n    protected subtrees:\n        | [QuadTree<T>, QuadTree<T>, QuadTree<T>, QuadTree<T>]\n        | null = null;\n    protected pairs: [AABB, T][] = [];\n\n    constructor(\n        readonly boundingBox: AABB,\n        readonly depth: number,\n        readonly innerNodeCapacity: number = 16,\n    ) {}\n\n    insert(boundingBox: AABB, value: T) {\n        if (!boundingBoxesOverlap(boundingBox, this.boundingBox)) return false;\n\n        if (this.depth > 0 && this.pairs.length >= this.innerNodeCapacity) {\n            this.ensureSubtrees();\n            for (let i = 0; i < this.subtrees!.length; i++) {\n                const tree = this.subtrees![i];\n                tree.insert(boundingBox, value);\n            }\n        } else {\n            this.pairs.push([boundingBox, value]);\n        }\n\n        return true;\n    }\n\n    find(boundingBox: AABB, set: Set<T> = new Set()): Set<T> {\n        if (!boundingBoxesOverlap(boundingBox, this.boundingBox)) return set;\n\n        for (let i = 0; i < this.pairs.length; i++) {\n            const [key, value] = this.pairs[i];\n            if (boundingBoxesOverlap(boundingBox, key)) {\n                set.add(value);\n            }\n        }\n\n        if (this.subtrees) {\n            for (let i = 0; i < this.subtrees.length; i++) {\n                const tree = this.subtrees[i];\n                tree.find(boundingBox, set);\n            }\n        }\n\n        return set;\n    }\n\n    findOnLineSegment(seg: LineSegment, set: Set<T> = new Set()): Set<T> {\n        if (!lineSegmentAABBIntersect(seg, this.boundingBox)) return set;\n\n        for (const [key, value] of this.pairs) {\n            if (lineSegmentAABBIntersect(seg, key)) {\n                set.add(value);\n            }\n        }\n\n        if (this.subtrees) {\n            for (const tree of this.subtrees) {\n                tree.findOnLineSegment(seg, set);\n            }\n        }\n\n        return set;\n    }\n\n    private ensureSubtrees() {\n        if (this.subtrees) return;\n\n        const { top, right, bottom, left } = this.boundingBox;\n        const midX = (this.boundingBox.left + this.boundingBox.right) / 2;\n        const midY = (this.boundingBox.top + this.boundingBox.bottom) / 2;\n\n        this.subtrees = [\n            new QuadTree(\n                { top, right: midX, bottom: midY, left },\n                this.depth - 1,\n                this.innerNodeCapacity,\n            ),\n            new QuadTree(\n                { top, right, bottom: midY, left: midX },\n                this.depth - 1,\n                this.innerNodeCapacity,\n            ),\n            new QuadTree(\n                { top: midY, right: midX, bottom, left },\n                this.depth - 1,\n                this.innerNodeCapacity,\n            ),\n            new QuadTree(\n                { top: midY, right, bottom, left: midX },\n                this.depth - 1,\n                this.innerNodeCapacity,\n            ),\n        ];\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { PathCubicSegment } from \"../primitives/PathSegment\";\n\nconst EPS = 1e-12;\n\nexport function pathCubicSegmentSelfIntersection(\n    seg: PathCubicSegment,\n): [number, number] | null {\n    // https://math.stackexchange.com/questions/3931865/self-intersection-of-a-cubic-bezier-interpretation-of-the-solution\n\n    const A = seg[1];\n    const B = seg[2];\n    const C = seg[3];\n    const D = seg[4];\n\n    const ax = -A[0] + 3 * B[0] - 3 * C[0] + D[0];\n    const ay = -A[1] + 3 * B[1] - 3 * C[1] + D[1];\n    const bx = 3 * A[0] - 6 * B[0] + 3 * C[0];\n    const by = 3 * A[1] - 6 * B[1] + 3 * C[1];\n    const cx = -3 * A[0] + 3 * B[0];\n    const cy = -3 * A[1] + 3 * B[1];\n\n    const M = ay * bx - ax * by;\n    const N = ax * cy - ay * cx;\n\n    const K =\n        (-3 * ax * ax * cy * cy +\n            6 * ax * ay * cx * cy +\n            4 * ax * bx * by * cy -\n            4 * ax * by * by * cx -\n            3 * ay * ay * cx * cx -\n            4 * ay * bx * bx * cy +\n            4 * ay * bx * by * cx) /\n        (ax * ax * by * by - 2 * ax * ay * bx * by + ay * ay * bx * bx);\n\n    if (K < 0) return null;\n\n    const t1 = (N / M + Math.sqrt(K)) / 2;\n    const t2 = (N / M - Math.sqrt(K)) / 2;\n\n    if (EPS <= t1 && t1 <= 1 - EPS && EPS <= t2 && t2 <= 1 - EPS) {\n        return [t1, t2];\n    }\n\n    return null;\n}\n","/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 2x2 Matrix\n * @module mat2\n */\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\n\nexport function fromValues(m00, m01, m10, m11) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\n\nexport function set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3]; // Calculate the determinant\n\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n  return out;\n}\n/**\n * Calculates the determinant of a mat2\n *\n * @param {ReadonlyMat2} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n/**\n * Returns a string representation of a mat2\n *\n * @param {ReadonlyMat2} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3]);\n}\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {ReadonlyMat2} L the lower triangular matrix\n * @param {ReadonlyMat2} D the diagonal matrix\n * @param {ReadonlyMat2} U the upper triangular matrix\n * @param {ReadonlyMat2} a the input matrix to factorize\n */\n\nexport function LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 2x3 Matrix\n * @module mat2d\n * @description\n * A mat2d contains six elements defined as:\n * <pre>\n * [a, b,\n *  c, d,\n *  tx, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, b, 0,\n *  c, d, 0,\n *  tx, ty, 1]\n * </pre>\n * The last column is ignored so the array is shorter and operations are faster.\n */\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(6);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {mat2d} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\n\nexport function fromValues(a, b, c, d, tx, ty) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\n\nexport function set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {mat2d} out\n */\n\nexport function invert(out, a) {\n  var aa = a[0],\n      ab = a[1],\n      ac = a[2],\n      ad = a[3];\n  var atx = a[4],\n      aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to translate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to translate\n * @param {ReadonlyVec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\n\nexport function translate(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2d} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat2d} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n/**\n * Returns a string representation of a mat2d\n *\n * @param {ReadonlyMat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat2d(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);\n}\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2d} a The first matrix.\n * @param {ReadonlyMat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2d} a The first matrix.\n * @param {ReadonlyMat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));\n}\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { vec2 } from \"gl-matrix\";\n\nexport const TAU = 2 * Math.PI;\n\nexport function linMap(\n    value: number,\n    inMin: number,\n    inMax: number,\n    outMin: number,\n    outMax: number,\n) {\n    return ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;\n}\n\nexport function lerp(a: number, b: number, t: number) {\n    return a + (b - a) * t;\n}\n\nexport function rad2deg(rad: number) {\n    return (rad / Math.PI) * 180;\n}\n\nexport function deg2rad(deg: number) {\n    return (deg / 180) * Math.PI;\n}\n\nexport function vectorAngle(u: [number, number], v: [number, number]) {\n    const EPS = 1e-12;\n\n    const sign = Math.sign(u[0] * v[1] - u[1] * v[0]);\n\n    if (\n        sign === 0 &&\n        Math.abs(u[0] + v[0]) < EPS &&\n        Math.abs(u[1] + v[1]) < EPS\n    ) {\n        // TODO: u can be scaled\n        return Math.PI;\n    }\n\n    return sign * Math.acos(vec2.dot(u, v) / vec2.len(u) / vec2.len(v));\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\n\nexport type Vector = [number, number];\n\nexport function createVector(): Vector {\n    return [0, 0];\n}\n\nexport function vectorsEqual(a: Vector, b: Vector, eps: number = 0) {\n    return Math.abs(a[0] - b[0]) <= eps && Math.abs(a[1] - b[1]) <= eps;\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { mat2, mat2d, vec2 } from \"gl-matrix\";\n\nimport { deg2rad, lerp, TAU, vectorAngle } from \"../util/math\";\nimport {\n    AABB,\n    boundingBoxAroundPoint,\n    expandBoundingBox,\n    extendBoundingBox,\n    mergeBoundingBoxes,\n} from \"./AABB\";\nimport { createVector, Vector } from \"./Vector\";\n\nexport type PathLineSegment = [\"L\", Vector, Vector];\n\nexport type PathCubicSegment = [\"C\", Vector, Vector, Vector, Vector];\n\nexport type PathQuadraticSegment = [\"Q\", Vector, Vector, Vector];\n\nexport type PathArcSegment = [\n    \"A\",\n    Vector,\n    number, // rx\n    number, // ry\n    number, // rotation\n    boolean, // large-arc-flag\n    boolean, // sweep-flag\n    Vector,\n];\n\nexport type PathSegment =\n    | PathLineSegment\n    | PathCubicSegment\n    | PathQuadraticSegment\n    | PathArcSegment;\n\ntype PathArcSegmentCenterParametrization = {\n    center: Vector;\n    theta1: number;\n    deltaTheta: number;\n    rx: number;\n    ry: number;\n    phi: number;\n};\n\nexport function getStartPoint(seg: PathSegment): Vector {\n    return seg[1];\n}\n\nexport function getEndPoint(seg: PathSegment): Vector {\n    switch (seg[0]) {\n        case \"L\":\n            return seg[2];\n        case \"C\":\n            return seg[4];\n        case \"Q\":\n            return seg[3];\n        case \"A\":\n            return seg[7];\n    }\n}\n\nexport function reversePathSegment(seg: PathSegment): PathSegment {\n    switch (seg[0]) {\n        case \"L\":\n            return [\"L\", seg[2], seg[1]];\n        case \"C\":\n            return [\"C\", seg[4], seg[3], seg[2], seg[1]];\n        case \"Q\":\n            return [\"Q\", seg[3], seg[2], seg[1]];\n        case \"A\":\n            return [\n                \"A\",\n                seg[7],\n                seg[2],\n                seg[3],\n                seg[4],\n                seg[5],\n                !seg[6],\n                seg[1],\n            ];\n    }\n}\n\nexport const arcSegmentToCenter = (() => {\n    const xy1Prime = createVector();\n    const rotationMatrix = mat2.create();\n    const addend = createVector();\n    const cxy = createVector();\n\n    return function arcSegmentToCenter([\n        _A,\n        xy1,\n        rx,\n        ry,\n        phi,\n        fA,\n        fS,\n        xy2,\n    ]: PathArcSegment): PathArcSegmentCenterParametrization | null {\n        // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n        if (rx === 0 || ry === 0) {\n            return null;\n        }\n\n        // https://svgwg.org/svg2-draft/implnote.html#ArcConversionEndpointToCenter\n\n        mat2.fromRotation(rotationMatrix, -deg2rad(phi));\n\n        vec2.sub(xy1Prime, xy1, xy2);\n        vec2.scale(xy1Prime, xy1Prime, 0.5);\n        vec2.transformMat2(xy1Prime, xy1Prime, rotationMatrix);\n\n        let rx2 = rx * rx;\n        let ry2 = ry * ry;\n        const x1Prime2 = xy1Prime[0] * xy1Prime[0];\n        const y1Prime2 = xy1Prime[1] * xy1Prime[1];\n\n        // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        const lambda = x1Prime2 / rx2 + y1Prime2 / ry2 + 1e-12; // small epsilon needed because of float precision\n        if (lambda > 1) {\n            const lambdaSqrt = Math.sqrt(lambda);\n            rx *= lambdaSqrt;\n            ry *= lambdaSqrt;\n            const lambdaAbs = Math.abs(lambda);\n            rx2 *= lambdaAbs;\n            ry2 *= lambdaAbs;\n        }\n\n        const sign = fA === fS ? -1 : 1;\n        const multiplier = Math.sqrt(\n            (rx2 * ry2 - rx2 * y1Prime2 - ry2 * x1Prime2) /\n                (rx2 * y1Prime2 + ry2 * x1Prime2),\n        );\n        const cxPrime = sign * multiplier * ((rx * xy1Prime[1]) / ry);\n        const cyPrime = sign * multiplier * ((-ry * xy1Prime[0]) / rx);\n\n        mat2.transpose(rotationMatrix, rotationMatrix);\n        vec2.add(addend, xy1, xy2);\n        vec2.scale(addend, addend, 0.5);\n        vec2.transformMat2(cxy, [cxPrime, cyPrime], rotationMatrix);\n        vec2.add(cxy, cxy, addend);\n\n        const vec1: Vector = [\n            (xy1Prime[0] - cxPrime) / rx,\n            (xy1Prime[1] - cyPrime) / ry,\n        ];\n        const theta1 = vectorAngle([1, 0], vec1);\n        let deltaTheta = vectorAngle(vec1, [\n            (-xy1Prime[0] - cxPrime) / rx,\n            (-xy1Prime[1] - cyPrime) / ry,\n        ]);\n\n        if (!fS && deltaTheta > 0) {\n            deltaTheta -= TAU;\n        } else if (fS && deltaTheta < 0) {\n            deltaTheta += TAU;\n        }\n\n        return {\n            center: [cxy[0], cxy[1]],\n            theta1,\n            deltaTheta,\n            rx,\n            ry,\n            phi,\n        };\n    };\n})();\n\nexport const arcSegmentFromCenter = (() => {\n    const xy1 = createVector();\n    const xy2 = createVector();\n    const rotationMatrix = mat2.create();\n\n    return function arcSegmentFromCenter({\n        center,\n        theta1,\n        deltaTheta,\n        rx,\n        ry,\n        phi,\n    }: PathArcSegmentCenterParametrization): PathArcSegment {\n        // https://svgwg.org/svg2-draft/implnote.html#ArcConversionCenterToEndpoint\n        mat2.fromRotation(rotationMatrix, phi); // TODO: sign (also in sampleAt)\n\n        vec2.set(xy1, rx * Math.cos(theta1), ry * Math.sin(theta1));\n        vec2.transformMat2(xy1, xy1, rotationMatrix);\n        vec2.add(xy1, xy1, center);\n\n        vec2.set(\n            xy2,\n            rx * Math.cos(theta1 + deltaTheta),\n            ry * Math.sin(theta1 + deltaTheta),\n        );\n        vec2.transformMat2(xy2, xy2, rotationMatrix);\n        vec2.add(xy2, xy2, center);\n\n        const fA = Math.abs(deltaTheta) > Math.PI;\n\n        const fS = deltaTheta > 0;\n\n        return [\"A\", [xy1[0], xy1[1]], rx, ry, phi, fA, fS, [xy2[0], xy2[1]]];\n    };\n})();\n\nexport const samplePathSegmentAt = (() => {\n    const p01 = createVector();\n    const p12 = createVector();\n    const p23 = createVector();\n    const p012 = createVector();\n    const p123 = createVector();\n    const p = createVector();\n\n    return function samplePathSegmentAt(seg: PathSegment, t: number): Vector {\n        switch (seg[0]) {\n            case \"L\":\n                vec2.lerp(p, seg[1], seg[2], t);\n                break;\n            case \"C\":\n                vec2.lerp(p01, seg[1], seg[2], t);\n                vec2.lerp(p12, seg[2], seg[3], t);\n                vec2.lerp(p23, seg[3], seg[4], t);\n                vec2.lerp(p012, p01, p12, t);\n                vec2.lerp(p123, p12, p23, t);\n                vec2.lerp(p, p012, p123, t);\n                break;\n            case \"Q\":\n                vec2.lerp(p01, seg[1], seg[2], t);\n                vec2.lerp(p12, seg[2], seg[3], t);\n                vec2.lerp(p, p01, p12, t);\n                break;\n            case \"A\": {\n                const centerParametrization = arcSegmentToCenter(seg);\n                if (!centerParametrization) {\n                    // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n                    vec2.lerp(p, seg[1], seg[7], t);\n                    break;\n                }\n                const { deltaTheta, phi, theta1, rx, ry, center } =\n                    centerParametrization;\n                const theta = theta1 + t * deltaTheta;\n                vec2.set(p, rx * Math.cos(theta), ry * Math.sin(theta));\n                vec2.rotate(p, p, [0, 0], phi); // TODO: sign (also in fromCenter)\n                vec2.add(p, p, center);\n                break;\n            }\n        }\n\n        return [p[0], p[1]];\n    };\n})();\n\nexport const arcSegmentToCubics = (() => {\n    const fromUnit = mat2d.create();\n    const matrix = mat2d.create();\n\n    return function arcSegmentToCubics(\n        arc: PathArcSegment,\n        maxDeltaTheta: number = Math.PI / 2,\n    ): PathCubicSegment[] | [PathLineSegment] {\n        const centerParametrization = arcSegmentToCenter(arc);\n\n        if (!centerParametrization) {\n            // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n            // \"If rx = 0 or ry = 0, then treat this as a straight line from (x1, y1) to (x2, y2) and stop.\"\n            return [[\"L\", arc[1], arc[7]]];\n        }\n\n        const { center, theta1, deltaTheta, rx, ry } = centerParametrization;\n\n        const count = Math.ceil(Math.abs(deltaTheta) / maxDeltaTheta);\n\n        mat2d.fromTranslation(fromUnit, center);\n        mat2d.rotate(fromUnit, fromUnit, deg2rad(arc[4]));\n        mat2d.scale(fromUnit, fromUnit, [rx, ry]);\n\n        // https://pomax.github.io/bezierinfo/#circles_cubic\n        const cubics: PathCubicSegment[] = [];\n        const theta = deltaTheta / count;\n        const k = (4 / 3) * Math.tan(theta / 4);\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n        for (let i = 0; i < count; i++) {\n            const start: Vector = [1, 0];\n            const control1: Vector = [1, k];\n            const control2: Vector = [\n                cosTheta + k * sinTheta,\n                sinTheta - k * cosTheta,\n            ];\n            const end: Vector = [cosTheta, sinTheta];\n\n            mat2d.fromRotation(matrix, theta1 + i * theta);\n            mat2d.mul(matrix, fromUnit, matrix);\n            vec2.transformMat2d(start, start, matrix);\n            vec2.transformMat2d(control1, control1, matrix);\n            vec2.transformMat2d(control2, control2, matrix);\n            vec2.transformMat2d(end, end, matrix);\n\n            cubics.push([\"C\", start, control1, control2, end]);\n        }\n\n        return cubics;\n    };\n})();\n\nfunction evalCubic1d(\n    p0: number,\n    p1: number,\n    p2: number,\n    p3: number,\n    t: number,\n) {\n    const p01 = lerp(p0, p1, t);\n    const p12 = lerp(p1, p2, t);\n    const p23 = lerp(p2, p3, t);\n    const p012 = lerp(p01, p12, t);\n    const p123 = lerp(p12, p23, t);\n    return lerp(p012, p123, t);\n}\n\nfunction cubicBoundingInterval(p0: number, p1: number, p2: number, p3: number) {\n    let min = Math.min(p0, p3);\n    let max = Math.max(p0, p3);\n\n    const a = 3 * (-p0 + 3 * p1 - 3 * p2 + p3);\n    const b = 6 * (p0 - 2 * p1 + p2);\n    const c = 3 * (p1 - p0);\n    const D = b * b - 4 * a * c;\n\n    if (D < 0 || a === 0) {\n        // TODO: if a=0, solve linear\n        return [min, max];\n    }\n\n    const sqrtD = Math.sqrt(D);\n\n    const t0 = (-b - sqrtD) / (2 * a);\n    if (0 < t0 && t0 < 1) {\n        const x0 = evalCubic1d(p0, p1, p2, p3, t0);\n        min = Math.min(min, x0);\n        max = Math.max(max, x0);\n    }\n\n    const t1 = (-b + sqrtD) / (2 * a);\n    if (0 < t1 && t1 < 1) {\n        const x1 = evalCubic1d(p0, p1, p2, p3, t1);\n        min = Math.min(min, x1);\n        max = Math.max(max, x1);\n    }\n\n    return [min, max];\n}\n\nfunction evalQuadratic1d(p0: number, p1: number, p2: number, t: number) {\n    const p01 = lerp(p0, p1, t);\n    const p12 = lerp(p1, p2, t);\n    return lerp(p01, p12, t);\n}\n\nfunction quadraticBoundingInterval(p0: number, p1: number, p2: number) {\n    let min = Math.min(p0, p2);\n    let max = Math.max(p0, p2);\n\n    const denominator = p0 - 2 * p1 + p2;\n\n    if (denominator === 0) {\n        return [min, max];\n    }\n\n    const t = (p0 - p1) / denominator;\n    if (0 <= t && t <= 1) {\n        const x = evalQuadratic1d(p0, p1, p2, t);\n        min = Math.min(min, x);\n        max = Math.max(max, x);\n    }\n\n    return [min, max];\n}\n\nfunction inInterval(x: number, x0: number, x1: number) {\n    const mapped = (x - x0) / (x1 - x0);\n    return 0 <= mapped && mapped <= 1;\n}\n\nexport function pathSegmentBoundingBox(seg: PathSegment): AABB {\n    switch (seg[0]) {\n        case \"L\":\n            return {\n                top: Math.min(seg[1][1], seg[2][1]),\n                right: Math.max(seg[1][0], seg[2][0]),\n                bottom: Math.max(seg[1][1], seg[2][1]),\n                left: Math.min(seg[1][0], seg[2][0]),\n            };\n        case \"C\": {\n            const [left, right] = cubicBoundingInterval(\n                seg[1][0],\n                seg[2][0],\n                seg[3][0],\n                seg[4][0],\n            );\n            const [top, bottom] = cubicBoundingInterval(\n                seg[1][1],\n                seg[2][1],\n                seg[3][1],\n                seg[4][1],\n            );\n            return { top, right, bottom, left };\n        }\n        case \"Q\": {\n            const [left, right] = quadraticBoundingInterval(\n                seg[1][0],\n                seg[2][0],\n                seg[3][0],\n            );\n            const [top, bottom] = quadraticBoundingInterval(\n                seg[1][1],\n                seg[2][1],\n                seg[3][1],\n            );\n            return { top, right, bottom, left };\n        }\n        case \"A\": {\n            const centerParametrization = arcSegmentToCenter(seg);\n\n            if (!centerParametrization) {\n                return extendBoundingBox(\n                    boundingBoxAroundPoint(seg[1], 0),\n                    seg[7],\n                );\n            }\n\n            const { theta1, deltaTheta, phi, center, rx, ry } =\n                centerParametrization;\n\n            if (phi === 0 || rx === ry) {\n                const theta2 = theta1 + deltaTheta;\n                let boundingBox = extendBoundingBox(\n                    boundingBoxAroundPoint(seg[1], 0),\n                    seg[7],\n                );\n                // FIXME: the following gives false positives, resulting in larger boxes\n                if (\n                    inInterval(-Math.PI, theta1, theta2) ||\n                    inInterval(Math.PI, theta1, theta2)\n                ) {\n                    boundingBox = extendBoundingBox(boundingBox, [\n                        center[0] - rx,\n                        center[1],\n                    ]);\n                }\n                if (\n                    inInterval(-Math.PI / 2, theta1, theta2) ||\n                    inInterval((3 * Math.PI) / 2, theta1, theta2)\n                ) {\n                    boundingBox = extendBoundingBox(boundingBox, [\n                        center[0],\n                        center[1] - ry,\n                    ]);\n                }\n                if (\n                    inInterval(0, theta1, theta2) ||\n                    inInterval(2 * Math.PI, theta1, theta2)\n                ) {\n                    boundingBox = extendBoundingBox(boundingBox, [\n                        center[0] + rx,\n                        center[1],\n                    ]);\n                }\n                if (\n                    inInterval(Math.PI / 2, theta1, theta2) ||\n                    inInterval((5 * Math.PI) / 2, theta1, theta2)\n                ) {\n                    boundingBox = extendBoundingBox(boundingBox, [\n                        center[0],\n                        center[1] + ry,\n                    ]);\n                }\n                return expandBoundingBox(boundingBox, 1e-11); // TODO: get rid of expansion\n            }\n\n            // TODO: don't convert to cubics\n            const cubics = arcSegmentToCubics(seg, Math.PI / 16);\n            let boundingBox: AABB | null = null;\n            for (const seg of cubics) {\n                boundingBox = mergeBoundingBoxes(\n                    boundingBox,\n                    pathSegmentBoundingBox(seg),\n                );\n            }\n            if (!boundingBox) {\n                return boundingBoxAroundPoint(seg[1], 0); //  TODO: what to do here?\n            }\n            return boundingBox;\n        }\n    }\n}\n\nfunction splitLinearSegmentAt(\n    seg: PathLineSegment,\n    t: number,\n): [PathLineSegment, PathLineSegment] {\n    const a = seg[1];\n    const b = seg[2];\n\n    const p = vec2.lerp(createVector(), a, b, t) as Vector;\n\n    return [\n        [\"L\", a, p],\n        [\"L\", p, b],\n    ];\n}\n\nexport function splitCubicSegmentAt(\n    seg: PathCubicSegment,\n    t: number,\n): [PathCubicSegment, PathCubicSegment] {\n    // https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n    const p0 = seg[1];\n    const p1 = seg[2];\n    const p2 = seg[3];\n    const p3 = seg[4];\n\n    const p01 = vec2.lerp(createVector(), p0, p1, t) as Vector;\n    const p12 = vec2.lerp(createVector(), p1, p2, t) as Vector;\n    const p23 = vec2.lerp(createVector(), p2, p3, t) as Vector;\n    const p012 = vec2.lerp(createVector(), p01, p12, t) as Vector;\n    const p123 = vec2.lerp(createVector(), p12, p23, t) as Vector;\n    const p = vec2.lerp(createVector(), p012, p123, t) as Vector;\n\n    return [\n        [\"C\", p0, p01, p012, p],\n        [\"C\", p, p123, p23, p3],\n    ];\n}\n\nfunction splitQuadraticSegmentAt(\n    seg: PathQuadraticSegment,\n    t: number,\n): [PathQuadraticSegment, PathQuadraticSegment] {\n    // https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n    const p0 = seg[1];\n    const p1 = seg[2];\n    const p2 = seg[3];\n\n    const p01 = vec2.lerp(createVector(), p0, p1, t) as Vector;\n    const p12 = vec2.lerp(createVector(), p1, p2, t) as Vector;\n    const p = vec2.lerp(createVector(), p01, p12, t) as Vector;\n\n    return [\n        [\"Q\", p0, p01, p],\n        [\"Q\", p, p12, p2],\n    ];\n}\n\nfunction splitArcSegmentAt(\n    seg: PathArcSegment,\n    t: number,\n): [PathArcSegment, PathArcSegment] | [PathLineSegment, PathLineSegment] {\n    const centerParametrization = arcSegmentToCenter(seg);\n\n    if (!centerParametrization) {\n        // https://svgwg.org/svg2-draft/implnote.html#ArcCorrectionOutOfRangeRadii\n        return splitLinearSegmentAt([\"L\", seg[1], seg[7]], t);\n    }\n\n    const midDeltaTheta = centerParametrization.deltaTheta * t;\n    return [\n        arcSegmentFromCenter({\n            ...centerParametrization,\n            deltaTheta: midDeltaTheta,\n        }),\n        arcSegmentFromCenter({\n            ...centerParametrization,\n            theta1: centerParametrization.theta1 + midDeltaTheta,\n            deltaTheta: centerParametrization.deltaTheta - midDeltaTheta,\n        }),\n    ];\n}\n\nexport function splitSegmentAt(\n    seg: PathSegment,\n    t: number,\n): [PathSegment, PathSegment] {\n    switch (seg[0]) {\n        case \"L\":\n            return splitLinearSegmentAt(seg, t);\n        case \"C\":\n            return splitCubicSegmentAt(seg, t);\n        case \"Q\":\n            return splitQuadraticSegmentAt(seg, t);\n        case \"A\":\n            return splitArcSegmentAt(seg, t);\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Vector } from \"../primitives/Vector\";\n\ntype LineSegment = [Vector, Vector];\n\nconst COLLINEAR_EPS = Number.MIN_VALUE * 64;\n\nexport function lineSegmentIntersection(\n    [[x1, y1], [x2, y2]]: LineSegment,\n    [[x3, y3], [x4, y4]]: LineSegment,\n    eps: number,\n): [number, number] | null {\n    // https://en.wikipedia.org/wiki/Intersection_(geometry)#Two_line_segments\n\n    const a1 = x2 - x1;\n    const b1 = x3 - x4;\n    const c1 = x3 - x1;\n    const a2 = y2 - y1;\n    const b2 = y3 - y4;\n    const c2 = y3 - y1;\n\n    const denom = a1 * b2 - a2 * b1;\n\n    if (Math.abs(denom) < COLLINEAR_EPS) return null;\n\n    const s = (c1 * b2 - c2 * b1) / denom;\n    const t = (a1 * c2 - a2 * c1) / denom;\n\n    if (-eps <= s && s <= 1 + eps && -eps <= t && t <= 1 + eps) {\n        return [s, t];\n    }\n\n    return null;\n}\n\nexport function lineSegmentsIntersect(\n    seg1: LineSegment,\n    seg2: LineSegment,\n    eps: number,\n) {\n    return !!lineSegmentIntersection(seg1, seg2, eps);\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Epsilons } from \"../Epsilons\";\nimport {\n    AABB,\n    boundingBoxesOverlap,\n    boundingBoxMaxExtent,\n} from \"../primitives/AABB\";\nimport {\n    PathSegment,\n    pathSegmentBoundingBox,\n    splitSegmentAt,\n} from \"../primitives/PathSegment\";\nimport { Vector, vectorsEqual } from \"../primitives/Vector\";\nimport { lerp } from \"../util/math\";\nimport { lineSegmentIntersection, lineSegmentsIntersect } from \"./line-segment\";\nimport { lineSegmentAABBIntersect } from \"./line-segment-AABB\";\n\ntype IntersectionSegment = {\n    seg: PathSegment;\n    startParam: number;\n    endParam: number;\n    boundingBox: AABB;\n};\n\nfunction subdivideIntersectionSegment(\n    intSeg: IntersectionSegment,\n): IntersectionSegment[] {\n    const [seg0, seg1] = splitSegmentAt(intSeg.seg, 0.5);\n    const midParam = (intSeg.startParam + intSeg.endParam) / 2;\n    return [\n        {\n            seg: seg0,\n            startParam: intSeg.startParam,\n            endParam: midParam,\n            boundingBox: pathSegmentBoundingBox(seg0),\n        },\n        {\n            seg: seg1,\n            startParam: midParam,\n            endParam: intSeg.endParam,\n            boundingBox: pathSegmentBoundingBox(seg1),\n        },\n    ];\n}\n\nfunction pathSegmentToLineSegment(seg: PathSegment): [Vector, Vector] {\n    switch (seg[0]) {\n        case \"L\":\n            return [seg[1], seg[2]];\n        case \"C\":\n            return [seg[1], seg[4]];\n        case \"Q\":\n            return [seg[1], seg[3]];\n        case \"A\":\n            return [seg[1], seg[7]];\n    }\n}\n\nfunction intersectionSegmentsOverlap(\n    { seg: seg0, boundingBox: boundingBox0 }: IntersectionSegment,\n    { seg: seg1, boundingBox: boundingBox1 }: IntersectionSegment,\n) {\n    if (seg0[0] === \"L\") {\n        if (seg1[0] === \"L\") {\n            return lineSegmentsIntersect(\n                [seg0[1], seg0[2]],\n                [seg1[1], seg1[2]],\n                1e-6, // TODO: configurable\n            );\n        } else {\n            return lineSegmentAABBIntersect([seg0[1], seg0[2]], boundingBox1);\n        }\n    } else {\n        if (seg1[0] === \"L\") {\n            return lineSegmentAABBIntersect([seg1[1], seg1[2]], boundingBox0);\n        } else {\n            return boundingBoxesOverlap(boundingBox0, boundingBox1);\n        }\n    }\n}\n\nexport function segmentsEqual(\n    seg0: PathSegment,\n    seg1: PathSegment,\n    pointEpsilon: number,\n): boolean {\n    const type = seg0[0];\n\n    if (seg1[0] !== type) return false;\n\n    switch (type) {\n        case \"L\":\n            return (\n                vectorsEqual(seg0[1], seg1[1], pointEpsilon) &&\n                vectorsEqual(seg0[2], seg1[2] as Vector, pointEpsilon)\n            );\n        case \"C\":\n            return (\n                vectorsEqual(seg0[1], seg1[1], pointEpsilon) &&\n                vectorsEqual(seg0[2], seg1[2] as Vector, pointEpsilon) &&\n                vectorsEqual(seg0[3], seg1[3] as Vector, pointEpsilon) &&\n                vectorsEqual(seg0[4], seg1[4] as Vector, pointEpsilon)\n            );\n        case \"Q\":\n            return (\n                vectorsEqual(seg0[1], seg1[1], pointEpsilon) &&\n                vectorsEqual(seg0[2], seg1[2] as Vector, pointEpsilon) &&\n                vectorsEqual(seg0[3], seg1[3] as Vector, pointEpsilon)\n            );\n        case \"A\":\n            return (\n                vectorsEqual(seg0[1], seg1[1], pointEpsilon) &&\n                Math.abs(seg0[2] - (seg1[2] as number)) < pointEpsilon &&\n                Math.abs(seg0[3] - (seg1[3] as number)) < pointEpsilon &&\n                Math.abs(seg0[4] - (seg1[4] as number)) < pointEpsilon && // TODO: Phi can be anything if rx = ry. Also, handle rotations by Pi/2.\n                seg0[5] === seg1[5] &&\n                seg0[6] === seg1[6] &&\n                vectorsEqual(seg0[7], seg1[7] as Vector, pointEpsilon)\n            );\n    }\n}\n\nexport function pathSegmentIntersection(\n    seg0: PathSegment,\n    seg1: PathSegment,\n    endpoints: boolean,\n    eps: Epsilons,\n): [number, number][] {\n    if (seg0[0] === \"L\" && seg1[0] === \"L\") {\n        const st = lineSegmentIntersection(\n            [seg0[1], seg0[2]],\n            [seg1[1], seg1[2]],\n            eps.param,\n        );\n        if (st) {\n            if (\n                !endpoints &&\n                (st[0] < eps.param || st[0] > 1 - eps.param) &&\n                (st[1] < eps.param || st[1] > 1 - eps.param)\n            ) {\n                return [];\n            }\n            return [st];\n        }\n    }\n\n    // https://math.stackexchange.com/questions/20321/how-can-i-tell-when-two-cubic-b%C3%A9zier-curves-intersect\n\n    let pairs: [IntersectionSegment, IntersectionSegment][] = [\n        [\n            {\n                seg: seg0,\n                startParam: 0,\n                endParam: 1,\n                boundingBox: pathSegmentBoundingBox(seg0),\n            },\n            {\n                seg: seg1,\n                startParam: 0,\n                endParam: 1,\n                boundingBox: pathSegmentBoundingBox(seg1),\n            },\n        ],\n    ];\n\n    const params: [number, number][] = [];\n\n    while (pairs.length) {\n        const nextPairs: [IntersectionSegment, IntersectionSegment][] = [];\n\n        for (const [seg0, seg1] of pairs) {\n            if (segmentsEqual(seg0.seg, seg1.seg, eps.point)) {\n                // TODO: move this outside of this loop?\n                continue; // TODO: what to do?\n            }\n\n            const isLinear0 =\n                boundingBoxMaxExtent(seg0.boundingBox) <= eps.linear;\n            const isLinear1 =\n                boundingBoxMaxExtent(seg1.boundingBox) <= eps.linear;\n\n            if (isLinear0 && isLinear1) {\n                const lineSegment0 = pathSegmentToLineSegment(seg0.seg);\n                const lineSegment1 = pathSegmentToLineSegment(seg1.seg);\n                const st = lineSegmentIntersection(\n                    lineSegment0,\n                    lineSegment1,\n                    eps.param,\n                );\n                if (st) {\n                    params.push([\n                        lerp(seg0.startParam, seg0.endParam, st[0]),\n                        lerp(seg1.startParam, seg1.endParam, st[1]),\n                    ]);\n                }\n            } else {\n                const subdivided0 = isLinear0\n                    ? [seg0]\n                    : subdivideIntersectionSegment(seg0);\n                const subdivided1 = isLinear1\n                    ? [seg1]\n                    : subdivideIntersectionSegment(seg1);\n\n                for (const seg0 of subdivided0) {\n                    for (const seg1 of subdivided1) {\n                        if (intersectionSegmentsOverlap(seg0, seg1)) {\n                            nextPairs.push([seg0, seg1]);\n                        }\n                    }\n                }\n            }\n        }\n\n        pairs = nextPairs;\n    }\n\n    if (!endpoints) {\n        return params.filter(\n            ([s, t]) =>\n                (s > eps.param && s < 1 - eps.param) ||\n                (t > eps.param && t < 1 - eps.param),\n        );\n    }\n\n    return params;\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\n\nexport function isNumber(val: unknown): val is number {\n    return typeof val === \"number\";\n}\n\nexport function isString(val: unknown): val is string {\n    return typeof val === \"string\";\n}\n\nexport function isBoolean(val: unknown): val is boolean {\n    return typeof val === \"boolean\";\n}\n\nexport const hasOwn = Object.hasOwn;\n\nexport function memoizeWeak<Obj extends Object, Args, Ret>(\n    fn: (obj: Obj, ...args: Args[]) => Ret,\n) {\n    const cache = new WeakMap<Obj, Ret>();\n    return (obj: Obj, ...args: Args[]) => {\n        if (cache.has(obj)) {\n            return cache.get(obj)!;\n        } else {\n            const val = fn(obj, ...args);\n            cache.set(obj, val);\n            return val;\n        }\n    };\n}\n\nexport function countIf<T>(arr: T[], pred: (value: T) => boolean): number {\n    return arr.reduce((acc: number, item: T) => acc + (pred(item) ? 1 : 0), 0);\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\n\nexport function* map<T1, T2>(\n    iter: Iterable<T1>,\n    fn: (val: T1, index: number) => T2,\n): Iterable<T2> {\n    let i = 0;\n    for (const val of iter) {\n        yield fn(val, i++);\n    }\n}\n\nexport function* flatMap<T1, T2>(\n    iter: Iterable<T1>,\n    fn: (val: T1, index: number) => Iterable<T2>,\n): Iterable<T2> {\n    let i = 0;\n    for (const val of iter) {\n        yield* fn(val, i++);\n    }\n}\n\nexport function* filter<T>(\n    iter: Iterable<T>,\n    fn: (val: T) => boolean,\n): Iterable<T> {\n    for (const val of iter) {\n        if (fn(val)) {\n            yield val;\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Epsilons } from \"./Epsilons\";\nimport { QuadTree } from \"./QuadTree\";\nimport {\n    assertCondition,\n    assertDefined,\n    assertEqual,\n    assertUnreachable,\n} from \"./assert\";\nimport { pathCubicSegmentSelfIntersection } from \"./intersections/path-cubic-segment-self-intersection\";\nimport {\n    pathSegmentIntersection,\n    segmentsEqual,\n} from \"./intersections/path-segment\";\nimport {\n    AABB,\n    boundingBoxAroundPoint,\n    boundingBoxMaxExtent,\n    mergeBoundingBoxes,\n} from \"./primitives/AABB\";\nimport { Path } from \"./primitives/Path\";\nimport {\n    getEndPoint,\n    getStartPoint,\n    PathSegment,\n    pathSegmentBoundingBox,\n    reversePathSegment,\n    samplePathSegmentAt,\n    splitCubicSegmentAt,\n    splitSegmentAt,\n} from \"./primitives/PathSegment\";\nimport { Vector, vectorsEqual } from \"./primitives/Vector\";\nimport { countIf, hasOwn, memoizeWeak } from \"./util/generic\";\nimport { map } from \"./util/iterators\";\nimport { linMap } from \"./util/math\";\n\nconst INTERSECTION_TREE_DEPTH = 8;\nconst POINT_TREE_DEPTH = 8;\n\nconst EPS: Epsilons = {\n    point: 1e-6,\n    linear: 1e-4,\n    param: 1e-8,\n};\n\nexport enum PathBooleanOperation {\n    Union,\n    Difference,\n    Intersection,\n    Exclusion,\n    Division,\n    Fracture,\n}\n\nexport enum FillRule {\n    NonZero,\n    EvenOdd,\n}\n\ntype MajorGraphEdgeStage1 = {\n    seg: PathSegment;\n    parent: number;\n};\n\ntype MajorGraphEdgeStage2 = MajorGraphEdgeStage1 & {\n    boundingBox: AABB;\n};\n\ntype MajorGraphEdge = MajorGraphEdgeStage2 & {\n    incidentVertices: [MajorGraphVertex, MajorGraphVertex];\n    directionFlag: boolean;\n    twin: MajorGraphEdge | null;\n};\n\ntype MajorGraphVertex = {\n    point: Vector;\n    outgoingEdges: MajorGraphEdge[];\n};\n\ntype MajorGraph = {\n    edges: MajorGraphEdge[];\n    vertices: MajorGraphVertex[];\n};\n\ntype MinorGraphEdge = {\n    segments: PathSegment[];\n    parent: number;\n    incidentVertices: [MinorGraphVertex, MinorGraphVertex];\n    directionFlag: boolean;\n    twin: MinorGraphEdge | null;\n};\n\ntype MinorGraphVertex = {\n    outgoingEdges: MinorGraphEdge[];\n};\n\ntype MinorGraphCycle = {\n    segments: PathSegment[];\n    parent: number;\n    directionFlag: boolean;\n};\n\ntype MinorGraph = {\n    edges: MinorGraphEdge[];\n    vertices: MinorGraphVertex[];\n    cycles: MinorGraphCycle[];\n};\n\ntype DualGraphHalfEdge = {\n    segments: PathSegment[];\n    parent: number;\n    incidentVertex: DualGraphVertex;\n    directionFlag: boolean;\n    twin: DualGraphHalfEdge | null;\n};\n\ntype DualGraphVertex = {\n    incidentEdges: DualGraphHalfEdge[];\n    flag: number;\n};\n\ntype DualGraphComponent = {\n    edges: DualGraphHalfEdge[];\n    vertices: DualGraphVertex[];\n    outerFace: DualGraphVertex | null;\n};\n\ntype NestingTree = {\n    component: DualGraphComponent;\n    outgoingEdges: Map<DualGraphVertex, NestingTree[]>;\n};\n\nfunction firstElementOfSet<T>(set: Set<T>): T {\n    return set.values().next().value;\n}\n\nfunction createObjectCounter(): (obj: Object) => number {\n    let i = 0;\n    return memoizeWeak(() => i++);\n}\n\nfunction segmentToEdge(\n    parent: 1 | 2,\n): (seg: PathSegment) => MajorGraphEdgeStage1 {\n    return (seg) => ({ seg, parent });\n}\n\nfunction splitAtSelfIntersections(edges: MajorGraphEdgeStage1[]) {\n    for (let i = 0; i < edges.length; i++) {\n        const edge = edges[i];\n        if (edge.seg[0] !== \"C\") continue;\n        const intersection = pathCubicSegmentSelfIntersection(edge.seg);\n        if (!intersection) continue;\n        if (intersection[0] > intersection[1]) {\n            intersection.reverse();\n        }\n        const [t1, t2] = intersection;\n        if (Math.abs(t1 - t2) < EPS.param) {\n            const [seg1, seg2] = splitCubicSegmentAt(edge.seg, t1);\n            edges[i] = {\n                seg: seg1,\n                parent: edge.parent,\n            };\n            edges.push({\n                seg: seg2,\n                parent: edge.parent,\n            });\n        } else {\n            const [seg1, tmpSeg] = splitCubicSegmentAt(edge.seg, t1);\n            const [seg2, seg3] = splitCubicSegmentAt(\n                tmpSeg,\n                (t2 - t1) / (1 - t1),\n            );\n            edges[i] = {\n                seg: seg1,\n                parent: edge.parent,\n            };\n            edges.push(\n                {\n                    seg: seg2,\n                    parent: edge.parent,\n                },\n                {\n                    seg: seg3,\n                    parent: edge.parent,\n                },\n            );\n        }\n    }\n}\n\nfunction splitAtIntersections(edges: MajorGraphEdgeStage1[]) {\n    const withBoundingBox: MajorGraphEdgeStage2[] = edges.map((edge) => ({\n        ...edge,\n        boundingBox: pathSegmentBoundingBox(edge.seg),\n    }));\n\n    const totalBoundingBox = withBoundingBox.reduce(\n        (acc, { boundingBox }) => mergeBoundingBoxes(acc, boundingBox),\n        null as AABB | null,\n    );\n\n    if (!totalBoundingBox) {\n        return { edges: [], totalBoundingBox: null };\n    }\n\n    const edgeTree = new QuadTree<number>(\n        totalBoundingBox,\n        INTERSECTION_TREE_DEPTH,\n    );\n\n    const splitsPerEdge: Record<number, number[]> = {};\n\n    function addSplit(i: number, t: number) {\n        if (!hasOwn(splitsPerEdge, i)) splitsPerEdge[i] = [];\n        splitsPerEdge[i].push(t);\n    }\n\n    for (let i = 0; i < withBoundingBox.length; i++) {\n        const edge = withBoundingBox[i];\n        const candidates = edgeTree.find(edge.boundingBox);\n        for (const j of candidates) {\n            const candidate = edges[j];\n            const includeEndpoints =\n                edge.parent !== candidate.parent ||\n                !(\n                    // TODO: this is not correct\n                    (\n                        vectorsEqual(\n                            getEndPoint(candidate.seg),\n                            getStartPoint(edge.seg),\n                            EPS.point,\n                        ) ||\n                        vectorsEqual(\n                            getStartPoint(candidate.seg),\n                            getEndPoint(edge.seg),\n                            EPS.point,\n                        )\n                    )\n                );\n            const intersection = pathSegmentIntersection(\n                edge.seg,\n                candidate.seg,\n                includeEndpoints,\n                EPS,\n            );\n            for (const [t0, t1] of intersection) {\n                addSplit(i, t0);\n                addSplit(j, t1);\n            }\n        }\n\n        /*\n         Insert the edge to the tree here, after checking intersections.\n         That way, each pair is only tested once.\n        */\n        edgeTree.insert(edge.boundingBox, i);\n    }\n\n    const newEdges: MajorGraphEdgeStage2[] = [];\n\n    for (let i = 0; i < withBoundingBox.length; i++) {\n        const edge = withBoundingBox[i];\n        if (!hasOwn(splitsPerEdge, i)) {\n            newEdges.push(edge);\n            continue;\n        }\n        const splits = splitsPerEdge[i];\n        splits.sort();\n        let tmpSeg = edge.seg;\n        let prevT = 0;\n        for (let j = 0; j < splits.length; j++) {\n            const t = splits[j];\n\n            if (t > 1 - EPS.param) break; // skip splits near end\n\n            const tt = (t - prevT) / (1 - prevT);\n            prevT = t;\n\n            if (tt < EPS.param) continue; // skip splits near start\n            if (tt > 1 - EPS.param) continue; // skip splits near end\n\n            const [seg1, seg2] = splitSegmentAt(tmpSeg, tt);\n            newEdges.push({\n                seg: seg1,\n                boundingBox: pathSegmentBoundingBox(seg1),\n                parent: edge.parent,\n            });\n            tmpSeg = seg2;\n        }\n        newEdges.push({\n            seg: tmpSeg,\n            boundingBox: pathSegmentBoundingBox(tmpSeg),\n            parent: edge.parent,\n        });\n    }\n\n    return { edges: newEdges, totalBoundingBox };\n}\n\nfunction findVertices(\n    edges: MajorGraphEdgeStage2[],\n    boundingBox: AABB,\n): MajorGraph {\n    const vertexTree = new QuadTree<MajorGraphVertex>(\n        boundingBox,\n        POINT_TREE_DEPTH,\n    );\n\n    const newVertices: MajorGraphVertex[] = [];\n\n    function getVertex(point: Vector): MajorGraphVertex {\n        const box = boundingBoxAroundPoint(point, EPS.point);\n        const existingVertices = vertexTree.find(box);\n        if (existingVertices.size) {\n            return firstElementOfSet(existingVertices);\n        } else {\n            const vertex: MajorGraphVertex = {\n                point,\n                outgoingEdges: [],\n            };\n            vertexTree.insert(box, vertex);\n            newVertices.push(vertex);\n            return vertex;\n        }\n    }\n\n    const getVertexId = createObjectCounter();\n    const vertexPairIdToEdges: Record<\n        string,\n        [MajorGraphEdgeStage2, MajorGraphEdge, MajorGraphEdge][]\n    > = {};\n\n    const newEdges = edges.flatMap((edge) => {\n        const startVertex = getVertex(getStartPoint(edge.seg));\n        const endVertex = getVertex(getEndPoint(edge.seg));\n\n        // discard zero-length segments\n        if (startVertex === endVertex) {\n            switch (edge.seg[0]) {\n                case \"L\":\n                    return [];\n                case \"C\":\n                    if (\n                        vectorsEqual(edge.seg[1], edge.seg[2], EPS.point) &&\n                        vectorsEqual(edge.seg[3], edge.seg[4], EPS.point)\n                    ) {\n                        return [];\n                    }\n                    break;\n                case \"Q\":\n                    if (vectorsEqual(edge.seg[1], edge.seg[2], EPS.point)) {\n                        return [];\n                    }\n                    break;\n                case \"A\":\n                    if (edge.seg[5] === false) {\n                        return [];\n                    }\n                    break;\n            }\n        }\n\n        const vertexPairId = `${getVertexId(startVertex)}:${getVertexId(endVertex)}`;\n        // TODO: check other direction\n        if (hasOwn(vertexPairIdToEdges, vertexPairId)) {\n            const existingEdge = vertexPairIdToEdges[vertexPairId].find(\n                (other) => segmentsEqual(other[0].seg, edge.seg, EPS.point),\n            );\n            if (existingEdge) {\n                existingEdge[1].parent |= edge.parent;\n                existingEdge[2].parent |= edge.parent;\n                return [];\n            }\n        }\n\n        const fwdEdge: MajorGraphEdge = {\n            ...edge,\n            incidentVertices: [startVertex, endVertex],\n            directionFlag: false,\n            twin: null,\n        };\n\n        const bwdEdge: MajorGraphEdge = {\n            ...edge,\n            incidentVertices: [endVertex, startVertex],\n            directionFlag: true,\n            twin: fwdEdge,\n        };\n\n        fwdEdge.twin = bwdEdge;\n\n        startVertex.outgoingEdges.push(fwdEdge);\n        endVertex.outgoingEdges.push(bwdEdge);\n\n        if (hasOwn(vertexPairIdToEdges, vertexPairId)) {\n            vertexPairIdToEdges[vertexPairId].push([edge, fwdEdge, bwdEdge]);\n        } else {\n            vertexPairIdToEdges[vertexPairId] = [[edge, fwdEdge, bwdEdge]];\n        }\n\n        return [fwdEdge, bwdEdge];\n    });\n\n    return {\n        edges: newEdges,\n        vertices: newVertices,\n    };\n}\n\nfunction getOrder(vertex: MajorGraphVertex | MinorGraphVertex) {\n    return vertex.outgoingEdges.length;\n}\n\nfunction computeMinor({ vertices }: MajorGraph): MinorGraph {\n    const newEdges: MinorGraphEdge[] = [];\n    const newVertices: MinorGraphVertex[] = [];\n\n    const toMinorVertex = memoizeWeak((_majorVertex: MajorGraphVertex) => {\n        const minorVertex: MinorGraphVertex = { outgoingEdges: [] };\n        newVertices.push(minorVertex);\n        return minorVertex;\n    }) as (majorVertex: MajorGraphVertex) => MinorGraphVertex;\n\n    const getEdgeId = createObjectCounter();\n    const idToEdge: Record<string, MinorGraphEdge> = {};\n    const visited = new WeakSet<MajorGraphVertex>();\n\n    // first handle components that are not cycles\n    for (const vertex of vertices) {\n        if (getOrder(vertex) === 2) continue;\n\n        const startVertex = toMinorVertex(vertex);\n\n        for (const startEdge of vertex.outgoingEdges) {\n            const segments: PathSegment[] = [];\n            let edge = startEdge;\n            while (\n                edge.parent === startEdge.parent &&\n                edge.directionFlag === startEdge.directionFlag &&\n                getOrder(edge.incidentVertices[1]) === 2\n            ) {\n                segments.push(edge.seg);\n                visited.add(edge.incidentVertices[1]);\n                const [edge1, edge2] = edge.incidentVertices[1].outgoingEdges;\n                assertCondition(\n                    edge1.twin === edge || edge2.twin === edge,\n                    \"Wrong twin structure.\",\n                );\n                edge = edge1.twin === edge ? edge2 : edge1; // choose the one we didn't use to come here\n            }\n            segments.push(edge.seg);\n            const endVertex = toMinorVertex(edge.incidentVertices[1]);\n            assertDefined(edge.twin, \"Edge doesn't have a twin.\");\n            assertDefined(startEdge.twin, \"Edge doesn't have a twin.\");\n            const edgeId = `${getEdgeId(startEdge)}-${getEdgeId(edge)}`;\n            const twinId = `${getEdgeId(edge.twin)}-${getEdgeId(startEdge.twin)}`;\n            const twin = idToEdge[twinId] ?? null;\n            const newEdge: MinorGraphEdge = {\n                segments,\n                parent: startEdge.parent,\n                incidentVertices: [startVertex, endVertex],\n                directionFlag: startEdge.directionFlag,\n                twin: twin,\n            };\n            if (twin) {\n                twin.twin = newEdge;\n            }\n            idToEdge[edgeId] = newEdge;\n            startVertex.outgoingEdges.push(newEdge);\n            newEdges.push(newEdge);\n        }\n    }\n\n    // handle cyclic components\n    const cycles: MinorGraphCycle[] = [];\n    for (const vertex of vertices) {\n        if (getOrder(vertex) !== 2 || visited.has(vertex)) continue;\n        let edge = vertex.outgoingEdges[0];\n        const cycle: MinorGraphCycle = {\n            segments: [],\n            parent: edge.parent,\n            directionFlag: edge.directionFlag,\n        };\n        do {\n            cycle.segments.push(edge.seg);\n            visited.add(edge.incidentVertices[0]);\n            assertEqual(\n                getOrder(edge.incidentVertices[1]),\n                2,\n                \"Found an unvisited vertex of order != 2.\",\n            );\n            const [edge1, edge2] = edge.incidentVertices[1].outgoingEdges;\n            assertCondition(\n                edge1.twin === edge || edge2.twin === edge,\n                \"Wrong twin structure.\",\n            );\n            edge = edge1.twin === edge ? edge2 : edge1;\n        } while (edge.incidentVertices[0] !== vertex);\n        cycles.push(cycle);\n    }\n\n    return {\n        edges: newEdges,\n        vertices: newVertices,\n        cycles,\n    };\n}\n\nfunction removeDanglingEdges(graph: MinorGraph) {\n    function walk(parent: 1 | 2) {\n        const keptVertices = new WeakSet<MinorGraphVertex>();\n        const vertexToLevel = new WeakMap<MinorGraphVertex, number>();\n\n        function visit(\n            vertex: MinorGraphVertex,\n            incomingEdge: MinorGraphEdge | null,\n            level: number,\n        ): number {\n            if (vertexToLevel.has(vertex)) {\n                return vertexToLevel.get(vertex)!;\n            }\n            vertexToLevel.set(vertex, level);\n\n            let minLevel = Infinity;\n            for (const edge of vertex.outgoingEdges) {\n                if (edge.parent & parent && edge !== incomingEdge) {\n                    minLevel = Math.min(\n                        minLevel,\n                        visit(edge.incidentVertices[1], edge.twin, level + 1),\n                    );\n                }\n            }\n\n            if (minLevel <= level) {\n                keptVertices.add(vertex);\n            }\n\n            return minLevel;\n        }\n\n        for (const edge of graph.edges) {\n            if (edge.parent & parent) {\n                visit(edge.incidentVertices[0], null, 0);\n            }\n        }\n\n        return keptVertices;\n    }\n\n    const keptVerticesA = walk(1);\n    const keptVerticesB = walk(2);\n\n    function keepVertex(vertex: MinorGraphVertex): boolean {\n        return keptVerticesA.has(vertex) || keptVerticesB.has(vertex);\n    }\n\n    function keepEdge(edge: MinorGraphEdge): boolean {\n        return (\n            ((edge.parent & 1) === 1 &&\n                keptVerticesA.has(edge.incidentVertices[0]) &&\n                keptVerticesA.has(edge.incidentVertices[1])) ||\n            ((edge.parent & 2) === 2 &&\n                keptVerticesB.has(edge.incidentVertices[0]) &&\n                keptVerticesB.has(edge.incidentVertices[1]))\n        );\n    }\n\n    graph.vertices = graph.vertices.filter(keepVertex);\n\n    for (const vertex of graph.vertices) {\n        vertex.outgoingEdges = vertex.outgoingEdges.filter(keepEdge);\n    }\n\n    graph.edges = graph.edges.filter(keepEdge);\n}\n\nfunction getIncidenceAngle({ directionFlag, segments }: MinorGraphEdge) {\n    let p0: Vector;\n    let p1: Vector;\n\n    const seg = segments[0]; // TODO: explain in comment why this is always the incident one in both fwd and bwd\n\n    if (!directionFlag) {\n        p0 = samplePathSegmentAt(seg, 0);\n        p1 = samplePathSegmentAt(seg, EPS.param);\n    } else {\n        p0 = samplePathSegmentAt(seg, 1);\n        p1 = samplePathSegmentAt(seg, 1 - EPS.param);\n    }\n\n    return Math.atan2(p1[1] - p0[1], p1[0] - p0[0]);\n}\n\nfunction sortOutgoingEdgesByAngle({ vertices }: MinorGraph) {\n    // TODO: this will hardly be a bottleneck, but profile whether memoization\n    //  actually helps and maybe use a simpler function that's monotonic\n    //  in angle.\n\n    const getAngle = memoizeWeak(getIncidenceAngle);\n\n    for (const vertex of vertices) {\n        if (getOrder(vertex) > 2) {\n            vertex.outgoingEdges.sort((a, b) => getAngle(a) - getAngle(b));\n        }\n    }\n}\n\nfunction getNextEdge(edge: MinorGraphEdge) {\n    const { outgoingEdges } = edge.incidentVertices[1];\n    const index = outgoingEdges.findIndex((other) => other.twin === edge);\n    return outgoingEdges[(index + 1) % outgoingEdges.length];\n}\n\nconst faceToPolygon = memoizeWeak((face: DualGraphVertex) =>\n    face.incidentEdges.flatMap((edge): Vector[] => {\n        const CNT = 64;\n\n        const points: Vector[] = [];\n\n        for (const seg of edge.segments) {\n            for (let i = 0; i < CNT; i++) {\n                const t0 = i / CNT;\n                const t = edge.directionFlag ? 1 - t0 : t0;\n                points.push(samplePathSegmentAt(seg, t));\n            }\n        }\n\n        return points;\n    }),\n);\n\nfunction intervalCrossesPoint(a: number, b: number, p: number) {\n    /*\n     This deserves its own routine because of the following trick.\n     We use different inequalities here to make sure we only count one of\n     two intervals that meet precisely at p.\n    */\n    const dy1 = a >= p;\n    const dy2 = b < p;\n    return dy1 === dy2;\n}\n\nfunction lineSegmentIntersectsHorizontalRay(\n    a: Vector,\n    b: Vector,\n    point: Vector,\n): boolean {\n    if (!intervalCrossesPoint(a[1], b[1], point[1])) return false;\n    const x = linMap(point[1], a[1], b[1], a[0], b[0]);\n    return x >= point[0];\n}\n\nfunction computePointWinding(polygon: Vector[], testedPoint: Vector) {\n    if (polygon.length <= 2) return 0;\n    let prevPoint = polygon[polygon.length - 1];\n    let winding = 0;\n    for (const point of polygon) {\n        if (lineSegmentIntersectsHorizontalRay(prevPoint, point, testedPoint)) {\n            winding += point[1] > prevPoint[1] ? -1 : 1;\n        }\n        prevPoint = point;\n    }\n    return winding;\n}\n\nfunction computeWinding(face: DualGraphVertex) {\n    const polygon = faceToPolygon(face);\n\n    for (let i = 0; i < polygon.length; i++) {\n        const a = polygon[i];\n        const b = polygon[(i + 1) % polygon.length];\n        const c = polygon[(i + 2) % polygon.length];\n        const testedPoint: Vector = [\n            (a[0] + b[0] + c[0]) / 3,\n            (a[1] + b[1] + c[1]) / 3,\n        ];\n        const winding = computePointWinding(polygon, testedPoint);\n        if (winding !== 0) {\n            return {\n                winding,\n                point: testedPoint,\n            };\n        }\n    }\n\n    assertUnreachable(\"No ear in polygon found.\");\n}\n\nfunction computeDual({ edges, cycles }: MinorGraph): DualGraphComponent[] {\n    const newVertices: DualGraphVertex[] = [];\n\n    const minorToDualEdge = new WeakMap<MinorGraphEdge, DualGraphHalfEdge>();\n    for (const startEdge of edges) {\n        if (minorToDualEdge.has(startEdge)) continue;\n        const face: DualGraphVertex = {\n            incidentEdges: [],\n            flag: 0,\n        };\n        let edge = startEdge;\n        do {\n            assertDefined(edge.twin, \"Edge doesn't have a twin\");\n            const twin = minorToDualEdge.get(edge.twin) ?? null;\n            const newEdge = {\n                segments: edge.segments,\n                parent: edge.parent,\n                incidentVertex: face,\n                directionFlag: edge.directionFlag,\n                twin,\n            };\n            if (twin) {\n                twin.twin = newEdge;\n            }\n            minorToDualEdge.set(edge, newEdge);\n            face.incidentEdges.push(newEdge);\n            edge = getNextEdge(edge);\n        } while (edge.incidentVertices[0] !== startEdge.incidentVertices[0]);\n        newVertices.push(face);\n    }\n\n    for (const cycle of cycles) {\n        const innerFace: DualGraphVertex = {\n            incidentEdges: [],\n            flag: 0,\n        };\n\n        const innerHalfEdge: DualGraphHalfEdge = {\n            segments: cycle.segments,\n            parent: cycle.parent,\n            incidentVertex: innerFace,\n            directionFlag: cycle.directionFlag,\n            twin: null,\n        };\n\n        const outerFace: DualGraphVertex = {\n            incidentEdges: [],\n            flag: 0,\n        };\n\n        const outerHalfEdge: DualGraphHalfEdge = {\n            segments: [...cycle.segments].reverse(),\n            parent: cycle.parent,\n            incidentVertex: outerFace,\n            directionFlag: !cycle.directionFlag,\n            twin: innerHalfEdge,\n        };\n\n        innerHalfEdge.twin = outerHalfEdge;\n        innerFace.incidentEdges.push(innerHalfEdge);\n        outerFace.incidentEdges.push(outerHalfEdge);\n\n        newVertices.push(innerFace, outerFace);\n    }\n\n    const components: DualGraphComponent[] = [];\n\n    const visitedVertices = new WeakSet<DualGraphVertex>();\n    const visitedEdges = new WeakSet<DualGraphHalfEdge>();\n    for (const vertex of newVertices) {\n        if (visitedVertices.has(vertex)) continue;\n        const componentVertices: DualGraphVertex[] = [];\n        const componentEdges: DualGraphHalfEdge[] = [];\n        const visit = (vertex: DualGraphVertex) => {\n            if (!visitedVertices.has(vertex)) {\n                componentVertices.push(vertex);\n            }\n            visitedVertices.add(vertex);\n            for (const edge of vertex.incidentEdges) {\n                if (visitedEdges.has(edge)) {\n                    continue;\n                }\n                const { twin } = edge;\n                assertDefined(twin, \"Edge doesn't have a twin.\");\n                componentEdges.push(edge, twin);\n                visitedEdges.add(edge);\n                visitedEdges.add(twin);\n                visit(twin.incidentVertex);\n            }\n        };\n        visit(vertex);\n        const outerFace = componentVertices.find(\n            (face) => computeWinding(face).winding < 0,\n        );\n        assertDefined(outerFace, \"No outer face of a component found.\");\n        assertEqual(\n            countIf(\n                componentVertices,\n                (face) => computeWinding(face).winding < 0,\n            ),\n            1,\n            \"Multiple outer faces found.\",\n        );\n        components.push({\n            vertices: componentVertices,\n            edges: componentEdges,\n            outerFace,\n        });\n    }\n\n    return components;\n}\n\nfunction boundingBoxIntersectsHorizontalRay(\n    boundingBox: AABB,\n    point: Vector,\n): boolean {\n    return (\n        intervalCrossesPoint(boundingBox.top, boundingBox.bottom, point[1]) &&\n        boundingBox.right >= point[0]\n    );\n}\n\nfunction pathSegmentHorizontalRayIntersectionCount(\n    origSeg: PathSegment,\n    point: Vector,\n): number {\n    type IntersectionSegment = { boundingBox: AABB; seg: PathSegment };\n    const totalBoundingBox = pathSegmentBoundingBox(origSeg);\n    if (!boundingBoxIntersectsHorizontalRay(totalBoundingBox, point)) return 0;\n    let segments: IntersectionSegment[] = [\n        { boundingBox: totalBoundingBox, seg: origSeg },\n    ];\n    let count = 0;\n    while (segments.length > 0) {\n        const nextSegments: IntersectionSegment[] = [];\n        for (const { boundingBox, seg } of segments) {\n            if (boundingBoxMaxExtent(boundingBox) < EPS.linear) {\n                if (\n                    lineSegmentIntersectsHorizontalRay(\n                        getStartPoint(seg),\n                        getEndPoint(seg),\n                        point,\n                    )\n                ) {\n                    count++;\n                }\n            } else {\n                const split = splitSegmentAt(seg, 0.5);\n                const boundingBox0 = pathSegmentBoundingBox(split[0]);\n                if (boundingBoxIntersectsHorizontalRay(boundingBox0, point)) {\n                    nextSegments.push({\n                        boundingBox: boundingBox0,\n                        seg: split[0],\n                    });\n                }\n                const boundingBox1 = pathSegmentBoundingBox(split[1]);\n                if (boundingBoxIntersectsHorizontalRay(boundingBox1, point)) {\n                    nextSegments.push({\n                        boundingBox: boundingBox1,\n                        seg: split[1],\n                    });\n                }\n            }\n        }\n        segments = nextSegments;\n    }\n    return count;\n}\n\nfunction testInclusion(a: DualGraphComponent, b: DualGraphComponent) {\n    // TODO: Intersection counting will fail if a curve touches the horizontal line but doesn't go through.\n    const testedPoint = getStartPoint(a.edges[0].segments[0]);\n    for (const face of b.vertices) {\n        if (face === b.outerFace) continue;\n        let count = 0;\n        for (const edge of face.incidentEdges) {\n            for (const seg of edge.segments) {\n                count += pathSegmentHorizontalRayIntersectionCount(\n                    seg,\n                    testedPoint,\n                );\n            }\n        }\n\n        if (count % 2 === 1) return face;\n    }\n    return null;\n}\n\nfunction computeNestingTree(components: DualGraphComponent[]): NestingTree[] {\n    let nestingTrees: NestingTree[] = [];\n\n    function insert(trees: NestingTree[], component: DualGraphComponent) {\n        let found = false;\n        for (const tree of trees) {\n            const face = testInclusion(component, tree.component);\n            if (face) {\n                if (tree.outgoingEdges.has(face)) {\n                    const children = tree.outgoingEdges.get(face)!;\n                    tree.outgoingEdges.set(face, insert(children, component));\n                } else {\n                    tree.outgoingEdges.set(face, [\n                        { component, outgoingEdges: new Map() },\n                    ]);\n                }\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            return trees;\n        } else {\n            const newTree: NestingTree = {\n                component,\n                outgoingEdges: new Map(),\n            };\n            const newTrees: NestingTree[] = [newTree];\n            for (const tree of trees) {\n                const face = testInclusion(tree.component, component);\n                if (face) {\n                    if (newTree.outgoingEdges.has(face)) {\n                        newTree.outgoingEdges.get(face)!.push(tree);\n                    } else {\n                        newTree.outgoingEdges.set(face, [tree]);\n                    }\n                } else {\n                    newTrees.push(tree);\n                }\n            }\n            return newTrees;\n        }\n    }\n\n    for (const component of components) {\n        nestingTrees = insert(nestingTrees, component);\n    }\n\n    return nestingTrees;\n}\n\nfunction getFlag(count: number, fillRule: FillRule) {\n    switch (fillRule) {\n        case FillRule.NonZero:\n            return count === 0 ? 0 : 1;\n        case FillRule.EvenOdd:\n            return count % 2 === 0 ? 0 : 1;\n    }\n}\n\nfunction flagFaces(\n    nestingTrees: NestingTree[],\n    aFillRule: FillRule,\n    bFillRule: FillRule,\n) {\n    function visitTree(\n        tree: NestingTree,\n        aRunningCount: number,\n        bRunningCount: number,\n    ) {\n        const visitedFaces = new WeakSet<DualGraphVertex>();\n\n        function visitFace(\n            face: DualGraphVertex,\n            aRunningCount: number,\n            bRunningCount: number,\n        ) {\n            if (visitedFaces.has(face)) return;\n            visitedFaces.add(face);\n            const aFlag = getFlag(aRunningCount, aFillRule);\n            const bFlag = getFlag(bRunningCount, bFillRule);\n            face.flag = aFlag | (bFlag << 1);\n            for (const edge of face.incidentEdges) {\n                const twin = edge.twin;\n                assertDefined(twin, \"Edge doesn't have a twin.\");\n                let nextACount = aRunningCount;\n                if (edge.parent & 1) {\n                    nextACount += edge.directionFlag ? -1 : 1;\n                }\n                let nextBCount = bRunningCount;\n                if (edge.parent & 2) {\n                    nextBCount += edge.directionFlag ? -1 : 1;\n                }\n                visitFace(twin.incidentVertex, nextACount, nextBCount);\n            }\n            if (tree.outgoingEdges.has(face)) {\n                const subtrees = tree.outgoingEdges.get(face)!;\n                for (const subtree of subtrees) {\n                    visitTree(subtree, aRunningCount, bRunningCount);\n                }\n            }\n        }\n\n        assertDefined(\n            tree.component.outerFace,\n            \"Component doesn't have an outer face.\",\n        );\n\n        visitFace(tree.component.outerFace, aRunningCount, bRunningCount);\n    }\n\n    for (const tree of nestingTrees) {\n        visitTree(tree, 0, 0);\n    }\n}\n\nfunction* getSelectedFaces(\n    nestingTrees: NestingTree[],\n    predicate: (face: DualGraphVertex) => boolean,\n): Iterable<DualGraphVertex> {\n    function* visit(tree: NestingTree): Iterable<DualGraphVertex> {\n        for (const face of tree.component.vertices) {\n            if (predicate(face)) {\n                yield face;\n            }\n        }\n        for (const subtrees of tree.outgoingEdges.values()) {\n            for (const subtree of subtrees) {\n                yield* visit(subtree);\n            }\n        }\n    }\n\n    for (const tree of nestingTrees) {\n        yield* visit(tree);\n    }\n}\n\nfunction* walkFaces(faces: Set<DualGraphVertex>) {\n    function isRemovedEdge(edge: DualGraphHalfEdge) {\n        assertDefined(edge.twin, \"Edge doesn't have a twin.\");\n        return (\n            faces.has(edge.incidentVertex) ===\n            faces.has(edge.twin.incidentVertex)\n        );\n    }\n\n    const edgeToNext = new WeakMap<DualGraphHalfEdge, DualGraphHalfEdge>();\n    for (const face of faces) {\n        let prevEdge = face.incidentEdges[face.incidentEdges.length - 1];\n        for (const edge of face.incidentEdges) {\n            edgeToNext.set(prevEdge, edge);\n            prevEdge = edge;\n        }\n    }\n\n    const visitedEdges = new WeakSet<DualGraphHalfEdge>();\n    for (const face of faces) {\n        for (const startEdge of face.incidentEdges) {\n            if (isRemovedEdge(startEdge) || visitedEdges.has(startEdge)) {\n                continue;\n            }\n            let edge = startEdge;\n            do {\n                if (edge.directionFlag) {\n                    yield* map(edge.segments, reversePathSegment);\n                } else {\n                    yield* edge.segments;\n                }\n                visitedEdges.add(edge);\n                edge = edgeToNext.get(edge)!;\n                while (isRemovedEdge(edge)) {\n                    assertDefined(edge.twin, \"Edge doesn't have a twin.\");\n                    edge = edgeToNext.get(edge.twin)!;\n                }\n            } while (edge !== startEdge);\n        }\n    }\n}\n\nfunction dumpFaces(\n    nestingTrees: NestingTree[],\n    predicate: (face: DualGraphVertex) => boolean,\n): Path[] {\n    const paths: Path[] = [];\n\n    function visit(tree: NestingTree) {\n        for (const face of tree.component.vertices) {\n            if (!predicate(face) || face === tree.component.outerFace) {\n                continue;\n            }\n\n            const path: Path = [];\n\n            for (const edge of face.incidentEdges) {\n                if (edge.directionFlag) {\n                    path.push(...edge.segments.map(reversePathSegment));\n                } else {\n                    path.push(...edge.segments);\n                }\n            }\n\n            // poke holes in the face\n            if (tree.outgoingEdges.has(face)) {\n                for (const subtree of tree.outgoingEdges.get(face)!) {\n                    const { outerFace } = subtree.component;\n\n                    assertDefined(outerFace, \"Component has no outer face.\");\n\n                    for (const edge of outerFace.incidentEdges) {\n                        if (edge.directionFlag) {\n                            path.push(...edge.segments.map(reversePathSegment));\n                        } else {\n                            path.push(...edge.segments);\n                        }\n                    }\n                }\n            }\n\n            paths.push(path);\n        }\n\n        for (const subtrees of tree.outgoingEdges.values()) {\n            for (const subtree of subtrees) {\n                visit(subtree);\n            }\n        }\n    }\n\n    for (const tree of nestingTrees) {\n        visit(tree);\n    }\n\n    return paths;\n}\n\nfunction majorGraphToDot({ vertices, edges }: MajorGraph) {\n    const toNumber = createObjectCounter();\n    return `digraph {\n${vertices.map((v) => `  ${toNumber(v)} [pos=\"${v.point.map((v) => v / 10).join(\",\")}!\"]`).join(\"\\n\")}\n${edges.map((edge) => \"  \" + edge.incidentVertices.map(toNumber).join(\" -> \")).join(\"\\n\")}\n}\n`;\n}\n\nfunction minorGraphToDot(edges: MinorGraphEdge[]) {\n    const toNumber = createObjectCounter();\n    return `digraph {\n${edges.map((edge) => \"  \" + edge.incidentVertices.map(toNumber).join(\" -> \")).join(\"\\n\")}\n}\n`;\n}\n\nfunction dualGraphToDot(components: DualGraphComponent[]) {\n    const toNumber = createObjectCounter();\n    return `strict graph {\n${components.map(({ edges }) => edges.map((edge) => `  ${toNumber(edge.incidentVertex)} -- ${toNumber(edge.twin!.incidentVertex)}`).join(\"\\n\")).join(\"\\n\")}\n}\n`;\n}\n\nfunction nestingTreesToDot(trees: NestingTree[]) {\n    const toNumber = createObjectCounter();\n    let out = \"digraph {\\n\";\n\n    function visit(tree: NestingTree) {\n        for (const edges of tree.outgoingEdges.values()) {\n            for (const subtree of edges) {\n                out += `  ${toNumber(tree.component)} -> ${toNumber(subtree.component)}\\n`;\n                visit(subtree);\n            }\n        }\n    }\n\n    trees.forEach(visit);\n\n    return out + \"}\\n\";\n}\n\nconst operationPredicates: Record<\n    PathBooleanOperation,\n    (face: DualGraphVertex) => boolean\n> = {\n    [PathBooleanOperation.Union]: ({ flag }) => flag > 0,\n    [PathBooleanOperation.Difference]: ({ flag }) => flag === 1,\n    [PathBooleanOperation.Intersection]: ({ flag }) => flag === 3,\n    [PathBooleanOperation.Exclusion]: ({ flag }) => flag === 1 || flag === 2,\n    [PathBooleanOperation.Division]: ({ flag }) => (flag & 1) === 1,\n    [PathBooleanOperation.Fracture]: ({ flag }) => flag > 0,\n};\n\nexport function pathBoolean(\n    a: Path,\n    aFillRule: FillRule,\n    b: Path,\n    bFillRule: FillRule,\n    op: PathBooleanOperation,\n): Path[] {\n    const unsplitEdges = [\n        ...map(a, segmentToEdge(1)),\n        ...map(b, segmentToEdge(2)),\n    ];\n\n    splitAtSelfIntersections(unsplitEdges);\n\n    const { edges: splitEdges, totalBoundingBox } =\n        splitAtIntersections(unsplitEdges);\n\n    if (!totalBoundingBox) {\n        // input geometry is empty\n        return [];\n    }\n\n    const majorGraph = findVertices(splitEdges, totalBoundingBox);\n    // console.log(majorGraphToDot(majorGraph));\n\n    const minorGraph = computeMinor(majorGraph);\n    // console.log(minorGraphToDot(minorGraph.edges));\n    // console.dir(minorGraph.cycles, { depth: 4 });\n\n    removeDanglingEdges(minorGraph);\n    // console.log(minorGraphToDot(minorGraph.edges));\n\n    sortOutgoingEdgesByAngle(minorGraph);\n\n    const dualGraphComponents = computeDual(minorGraph);\n    // console.log(dualGraphToDot(dualGraphComponents));\n\n    const nestingTrees = computeNestingTree(dualGraphComponents);\n    // console.log(nestingTrees.length, nestingTreesToDot(nestingTrees));\n\n    flagFaces(nestingTrees, aFillRule, bFillRule);\n\n    const predicate = operationPredicates[op];\n\n    switch (op) {\n        case PathBooleanOperation.Division:\n        case PathBooleanOperation.Fracture:\n            return dumpFaces(nestingTrees, predicate);\n        default: {\n            const selectedFaces = new Set(\n                getSelectedFaces(nestingTrees, predicate),\n            );\n            return [[...walkFaces(selectedFaces)]];\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { PathCommand, toAbsoluteCommands } from \"./PathCommand\";\nimport { PathSegment } from \"./PathSegment\";\nimport { Vector, vectorsEqual } from \"./Vector\";\n\nexport type Path = PathSegment[];\n\nfunction reflectControlPoint(point: Vector, controlPoint: Vector): Vector {\n    return [2 * point[0] - controlPoint[0], 2 * point[1] - controlPoint[1]];\n}\n\nexport function* pathFromCommands(\n    commands: Iterable<PathCommand>,\n): Iterable<PathSegment> {\n    let firstPoint: Vector | null = null;\n    let lastPoint: Vector | null = null;\n    let lastControlPoint: Vector | null = null;\n\n    function badSequence(): never {\n        throw new Error(\"Bad SVG path data sequence.\");\n    }\n\n    for (const cmd of toAbsoluteCommands(commands)) {\n        switch (cmd[0]) {\n            case \"M\":\n                lastPoint = firstPoint = cmd[1];\n                lastControlPoint = null;\n                break;\n            case \"L\":\n                if (!lastPoint) badSequence();\n                yield [\"L\", lastPoint, cmd[1]];\n                lastPoint = cmd[1];\n                lastControlPoint = null;\n                break;\n            case \"C\":\n                if (!lastPoint) badSequence();\n                yield [\"C\", lastPoint, cmd[1], cmd[2], cmd[3]];\n                lastPoint = cmd[3];\n                lastControlPoint = cmd[2];\n                break;\n            case \"S\":\n                if (!lastPoint) badSequence();\n                if (!lastControlPoint) badSequence(); // TODO: really?\n                yield [\n                    \"C\",\n                    lastPoint,\n                    reflectControlPoint(lastPoint, lastControlPoint),\n                    cmd[1],\n                    cmd[2],\n                ];\n                lastPoint = cmd[2];\n                lastControlPoint = cmd[1];\n                break;\n            case \"Q\":\n                if (!lastPoint) badSequence();\n                yield [\"Q\", lastPoint, cmd[1], cmd[2]];\n                lastPoint = cmd[2];\n                lastControlPoint = cmd[1];\n                break;\n            case \"T\":\n                if (!lastPoint) badSequence();\n                if (!lastControlPoint) badSequence(); // TODO: really?\n                lastControlPoint = reflectControlPoint(\n                    lastPoint,\n                    lastControlPoint,\n                );\n                yield [\"Q\", lastPoint, lastControlPoint, cmd[1]];\n                lastPoint = cmd[1];\n                break;\n            case \"A\":\n                if (!lastPoint) badSequence();\n                yield [\n                    \"A\",\n                    lastPoint,\n                    cmd[1],\n                    cmd[2],\n                    cmd[3],\n                    cmd[4],\n                    cmd[5],\n                    cmd[6],\n                ];\n                lastPoint = cmd[6];\n                lastControlPoint = null;\n                break;\n            case \"Z\":\n            case \"z\":\n                if (!lastPoint) badSequence();\n                if (!firstPoint) badSequence(); // TODO: really?\n                yield [\"L\", lastPoint, firstPoint];\n                lastPoint = firstPoint;\n                lastControlPoint = null;\n                break;\n        }\n    }\n}\n\nexport function* pathToCommands(\n    segments: Iterable<PathSegment>,\n    eps: number = 1e-4,\n): Iterable<PathCommand> {\n    let lastPoint: Vector | null = null;\n    for (const seg of segments) {\n        if (!lastPoint || !vectorsEqual(seg[1], lastPoint, eps)) {\n            yield [\"M\", seg[1]];\n        }\n\n        switch (seg[0]) {\n            case \"L\":\n                yield [\"L\", (lastPoint = seg[2])];\n                break;\n            case \"C\":\n                yield [\"C\", seg[2], seg[3], (lastPoint = seg[4])];\n                break;\n            case \"Q\":\n                yield [\"Q\", seg[2], (lastPoint = seg[3])];\n                break;\n            case \"A\":\n                yield [\n                    \"A\",\n                    seg[2],\n                    seg[3],\n                    seg[4],\n                    seg[5],\n                    seg[6],\n                    (lastPoint = seg[7]),\n                ];\n                break;\n        }\n    }\n}\n","/*\n * SPDX-FileCopyrightText: 2024 Adam Platkevič <rflashster@gmail.com>\n *\n * SPDX-License-Identifier: MIT\n */\nimport { Vector } from \"./Vector\";\n\nexport type AbsolutePathCommand =\n    | [\"M\", Vector]\n    | [\"L\", Vector]\n    | [\"C\", Vector, Vector, Vector]\n    | [\"S\", Vector, Vector]\n    | [\"Q\", Vector, Vector]\n    | [\"T\", Vector]\n    | [\"A\", number, number, number, boolean, boolean, Vector]\n    | [\"Z\"]\n    | [\"z\"];\n\ntype RelativePathCommand =\n    | [\"H\", number]\n    | [\"V\", number]\n    | [\"m\", number, number]\n    | [\"l\", number, number]\n    | [\"h\", number]\n    | [\"v\", number]\n    | [\"c\", number, number, number, number, number, number]\n    | [\"s\", number, number, number, number]\n    | [\"q\", number, number, number, number]\n    | [\"t\", number, number]\n    | [\"a\", number, number, number, boolean, boolean, number, number];\n\nexport type PathCommand = AbsolutePathCommand | RelativePathCommand;\n\nexport function* toAbsoluteCommands(\n    commands: Iterable<PathCommand>,\n): Iterable<AbsolutePathCommand> {\n    let lastPoint: Vector = [0, 0];\n    let firstPoint = lastPoint;\n\n    for (const cmd of commands) {\n        switch (cmd[0]) {\n            case \"M\":\n                yield cmd;\n                lastPoint = firstPoint = cmd[1];\n                break;\n            case \"L\":\n                yield cmd;\n                lastPoint = cmd[1];\n                break;\n            case \"C\":\n                yield cmd;\n                lastPoint = cmd[3];\n                break;\n            case \"S\":\n                yield cmd;\n                lastPoint = cmd[2];\n                break;\n            case \"Q\":\n                yield cmd;\n                lastPoint = cmd[2];\n                break;\n            case \"T\":\n                yield cmd;\n                lastPoint = cmd[1];\n                break;\n            case \"A\":\n                yield cmd;\n                lastPoint = cmd[6];\n                break;\n            case \"Z\":\n            case \"z\":\n                lastPoint = firstPoint;\n                yield [\"Z\"];\n                break;\n            case \"H\":\n                lastPoint = [cmd[1], lastPoint[1]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"V\":\n                lastPoint = [lastPoint[0], cmd[1]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"m\":\n                lastPoint = firstPoint = [\n                    lastPoint[0] + cmd[1],\n                    lastPoint[1] + cmd[2],\n                ];\n                yield [\"M\", lastPoint];\n                break;\n            case \"l\":\n                lastPoint = [lastPoint[0] + cmd[1], lastPoint[1] + cmd[2]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"h\":\n                lastPoint = [lastPoint[0] + cmd[1], lastPoint[1]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"v\":\n                lastPoint = [lastPoint[0], lastPoint[1] + cmd[1]];\n                yield [\"L\", lastPoint];\n                break;\n            case \"c\":\n                yield [\n                    \"C\",\n                    [lastPoint[0] + cmd[1], lastPoint[1] + cmd[2]],\n                    [lastPoint[0] + cmd[3], lastPoint[1] + cmd[4]],\n                    (lastPoint = [\n                        lastPoint[0] + cmd[5],\n                        lastPoint[1] + cmd[6],\n                    ]),\n                ];\n                break;\n            case \"s\":\n                yield [\n                    \"S\",\n                    [lastPoint[0] + cmd[1], lastPoint[1] + cmd[2]],\n                    (lastPoint = [\n                        lastPoint[0] + cmd[3],\n                        lastPoint[1] + cmd[4],\n                    ]),\n                ];\n                break;\n            case \"q\":\n                yield [\n                    \"Q\",\n                    [lastPoint[0] + cmd[1], lastPoint[1] + cmd[2]],\n                    (lastPoint = [\n                        lastPoint[0] + cmd[3],\n                        lastPoint[1] + cmd[4],\n                    ]),\n                ];\n                break;\n            case \"t\":\n                yield [\n                    \"T\",\n                    (lastPoint = [\n                        lastPoint[0] + cmd[1],\n                        lastPoint[1] + cmd[2],\n                    ]),\n                ];\n                break;\n            case \"a\":\n                yield [\n                    \"A\",\n                    cmd[1],\n                    cmd[2],\n                    cmd[3],\n                    cmd[4],\n                    cmd[5],\n                    (lastPoint = [\n                        lastPoint[0] + cmd[6],\n                        lastPoint[1] + cmd[7],\n                    ]),\n                ];\n                break;\n        }\n    }\n}\n"],"names":["INSIDE","LEFT","RIGHT","BOTTOM","TOP","outCode","x","y","boundingBox","code","left","right","top","bottom","lineSegmentAABBIntersect","seg","x0","y0","x1","y1","outcode0","outcode1","outcodeOut","boundingBoxesOverlap","a","b","mergeBoundingBoxes","Math","min","max","extendBoundingBox","point","boundingBoxMaxExtent","boundingBoxAroundPoint","padding","QuadTree","fromPairs","pairs","depth","innerNodeCapacity","length","Error","i","tree","key","value","insert","constructor","this","subtrees","ensureSubtrees","push","find","set","Set","add","findOnLineSegment","midX","midY","EPS","pathCubicSegmentSelfIntersection","A","B","C","D","ax","ay","bx","by","cx","cy","M","N","K","t1","sqrt","t2","ARRAY_TYPE","Float32Array","Array","create","out","glMatrix.ARRAY_TYPE","fromRotation","rad","s","sin","c","cos","hypot","arguments","mul","a0","a1","a2","a3","a4","a5","b0","b1","b2","b3","b4","b5","scale","lerp","t","transformMat2","m","transformMat2d","len","sub","TAU","PI","deg2rad","deg","vectorAngle","u","v","sign","abs","acos","vec2.len","vectorsEqual","eps","getStartPoint","getEndPoint","reversePathSegment","arcSegmentToCenter","xy1Prime","rotationMatrix","mat2.create","addend","cxy","_A","xy1","rx","ry","phi","fA","fS","xy2","mat2.fromRotation","vec2.sub","vec2.scale","vec2.transformMat2","rx2","ry2","x1Prime2","y1Prime2","lambda","lambdaSqrt","lambdaAbs","multiplier","cxPrime","cyPrime","mat2.transpose","vec2.add","vec1","theta1","deltaTheta","center","arcSegmentFromCenter","vec2.set","samplePathSegmentAt","p01","p12","p23","p012","p123","p","vec2.lerp","centerParametrization","theta","p0","p1","sinC","cosC","vec2.rotate","arcSegmentToCubics","fromUnit","mat2d.create","matrix","arc","maxDeltaTheta","count","ceil","mat2d.fromTranslation","mat2d.rotate","v0","v1","mat2d.scale","cubics","k","tan","sinTheta","cosTheta","start","control1","control2","end","mat2d.fromRotation","mat2d.mul","vec2.transformMat2d","evalCubic1d","p2","p3","cubicBoundingInterval","sqrtD","t0","quadraticBoundingInterval","denominator","evalQuadratic1d","inInterval","mapped","pathSegmentBoundingBox","theta2","expandBoundingBox","splitLinearSegmentAt","splitCubicSegmentAt","splitSegmentAt","splitQuadraticSegmentAt","midDeltaTheta","splitArcSegmentAt","COLLINEAR_EPS","Number","MIN_VALUE","lineSegmentIntersection","x2","y2","x3","y3","x4","y4","c1","c2","denom","subdivideIntersectionSegment","intSeg","seg0","seg1","midParam","startParam","endParam","pathSegmentToLineSegment","intersectionSegmentsOverlap","boundingBox0","boundingBox1","seg2","lineSegmentsIntersect","segmentsEqual","pointEpsilon","type","pathSegmentIntersection","endpoints","st","param","params","nextPairs","isLinear0","linear","isLinear1","subdivided0","subdivided1","filter","hasOwn","Object","memoizeWeak","fn","cache","WeakMap","obj","args","has","get","val","map","iter","INTERSECTION_TREE_DEPTH","POINT_TREE_DEPTH","PathBooleanOperation","FillRule","createObjectCounter","segmentToEdge","parent","getOrder","vertex","outgoingEdges","getIncidenceAngle","directionFlag","segments","atan2","getNextEdge","edge","incidentVertices","index","findIndex","other","twin","exports","faceToPolygon","face","incidentEdges","flatMap","points","intervalCrossesPoint","lineSegmentIntersectsHorizontalRay","inMin","inMax","outMin","outMax","computePointWinding","polygon","testedPoint","prevPoint","winding","computeWinding","boundingBoxIntersectsHorizontalRay","pathSegmentHorizontalRayIntersectionCount","origSeg","totalBoundingBox","nextSegments","split","testInclusion","edges","vertices","outerFace","getFlag","fillRule","NonZero","EvenOdd","walkFaces","faces","isRemovedEdge","incidentVertex","edgeToNext","prevEdge","visitedEdges","WeakSet","startEdge","operationPredicates","Union","flag","Difference","Intersection","Exclusion","Division","Fracture","reflectControlPoint","controlPoint","aFillRule","bFillRule","op","unsplitEdges","intersection","reverse","tmpSeg","seg3","splitAtSelfIntersections","splitEdges","withBoundingBox","reduce","acc","edgeTree","splitsPerEdge","addSplit","candidates","j","candidate","includeEndpoints","newEdges","splits","sort","prevT","tt","splitAtIntersections","majorGraph","vertexTree","newVertices","getVertex","box","existingVertices","size","values","next","firstElementOfSet","getVertexId","vertexPairIdToEdges","startVertex","endVertex","vertexPairId","existingEdge","fwdEdge","bwdEdge","findVertices","minorGraph","toMinorVertex","_majorVertex","minorVertex","getEdgeId","idToEdge","visited","edge1","edge2","edgeId","newEdge","cycles","cycle","computeMinor","graph","walk","keptVertices","vertexToLevel","visit","incomingEdge","level","minLevel","Infinity","keptVerticesA","keptVerticesB","keepEdge","removeDanglingEdges","getAngle","sortOutgoingEdgesByAngle","nestingTrees","components","trees","component","found","children","Map","newTree","newTrees","computeNestingTree","minorToDualEdge","innerFace","innerHalfEdge","outerHalfEdge","visitedVertices","componentVertices","componentEdges","computeDual","visitTree","aRunningCount","bRunningCount","visitedFaces","visitFace","aFlag","bFlag","nextACount","nextBCount","subtree","flagFaces","predicate","paths","path","dumpFaces","selectedFaces","getSelectedFaces","commands","firstPoint","lastPoint","lastControlPoint","badSequence","cmd","toAbsoluteCommands"],"mappings":"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","x_google_ignoreList":[4,5,6,7]}