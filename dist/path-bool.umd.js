var t,n;t=this,n=function(t){const n=0,e=1,o=2,r=4,s=8;function i(t,i,a){let c=n;return t<a.left?c|=e:t>a.right&&(c|=o),i<a.top?c|=r:i>a.bottom&&(c|=s),c}function a(t,n){let[[a,c],[u,f]]=t,d=i(a,c,n),l=i(u,f,n);for(;;){if(!(d|l))return!0;if(d&l)return!1;{const{top:t,right:g,bottom:h,left:p}=n;let m,b;const M=l>d?l:d;M&s?(m=a+(u-a)*(h-c)/(f-c),b=h):M&r?(m=a+(u-a)*(t-c)/(f-c),b=t):M&o?(b=c+(f-c)*(g-a)/(u-a),m=g):M&e&&(b=c+(f-c)*(p-a)/(u-a),m=p),M==d?(a=m,c=b,d=i(a,c,n)):(u=m,f=b,l=i(u,f,n))}}}function c(t,n){return t.left<=n.right&&n.left<=t.right&&t.top<=n.bottom&&n.top<=t.bottom}function u(t,n){return t?{top:Math.min(t.top,n.top),right:Math.max(t.right,n.right),bottom:Math.max(t.bottom,n.bottom),left:Math.min(t.left,n.left)}:n}function f(t,n){return t?{top:Math.min(t.top,n[1]),right:Math.max(t.right,n[0]),bottom:Math.max(t.bottom,n[1]),left:Math.min(t.left,n[0])}:{top:n[1],right:n[0],bottom:n[1],left:n[0]}}function d(t){return Math.max(t.right-t.left,t.bottom-t.top)}function l(t,n){return{top:t[1]-n,right:t[0]+n,bottom:t[1]+n,left:t[0]-n}}class g{static fromPairs(t,n,e=8){if(0===t.length)throw new Error("QuadTree.fromPairs: at least one pair needed.");let o=t[0][0];for(let n=1;n<t.length;n++)o=u(o,t[n][0]);const r=new g(o,n,e);for(const[n,e]of t)r.insert(n,e);return r}constructor(t,n,e=16){this.boundingBox=t,this.depth=n,this.innerNodeCapacity=e,this.subtrees=null,this.pairs=[]}insert(t,n){if(!c(t,this.boundingBox))return!1;if(this.depth>0&&this.pairs.length>=this.innerNodeCapacity){this.ensureSubtrees();for(let e=0;e<this.subtrees.length;e++)this.subtrees[e].insert(t,n)}else this.pairs.push([t,n]);return!0}find(t,n=new Set){if(!c(t,this.boundingBox))return n;for(let e=0;e<this.pairs.length;e++){const[o,r]=this.pairs[e];c(t,o)&&n.add(r)}if(this.subtrees)for(let e=0;e<this.subtrees.length;e++)this.subtrees[e].find(t,n);return n}findOnLineSegment(t,n=new Set){if(!a(t,this.boundingBox))return n;for(const[e,o]of this.pairs)a(t,e)&&n.add(o);if(this.subtrees)for(const e of this.subtrees)e.findOnLineSegment(t,n);return n}ensureSubtrees(){if(this.subtrees)return;const{top:t,right:n,bottom:e,left:o}=this.boundingBox,r=(this.boundingBox.left+this.boundingBox.right)/2,s=(this.boundingBox.top+this.boundingBox.bottom)/2;this.subtrees=[new g({top:t,right:r,bottom:s,left:o},this.depth-1,this.innerNodeCapacity),new g({top:t,right:n,bottom:s,left:r},this.depth-1,this.innerNodeCapacity),new g({top:s,right:r,bottom:e,left:o},this.depth-1,this.innerNodeCapacity),new g({top:s,right:n,bottom:e,left:r},this.depth-1,this.innerNodeCapacity)]}}const h=1e-12;function p(t){const n=t[1],e=t[2],o=t[3],r=t[4],s=-n[0]+3*e[0]-3*o[0]+r[0],i=-n[1]+3*e[1]-3*o[1]+r[1],a=3*n[0]-6*e[0]+3*o[0],c=3*n[1]-6*e[1]+3*o[1],u=-3*n[0]+3*e[0],f=-3*n[1]+3*e[1],d=i*a-s*c,l=s*f-i*u,g=(-3*s*s*f*f+6*s*i*u*f+4*s*a*c*f-4*s*c*c*u-3*i*i*u*u-4*i*a*a*f+4*i*a*c*u)/(s*s*c*c-2*s*i*a*c+i*i*a*a);if(g<0)return null;const p=(l/d+Math.sqrt(g))/2,m=(l/d-Math.sqrt(g))/2;return h<=p&&p<=1-h&&h<=m&&m<=1-h?[p,m]:null}var m="undefined"!=typeof Float32Array?Float32Array:Array;function b(){var t=new m(4);return m!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t}function M(t,n){var e=Math.sin(n),o=Math.cos(n);return t[0]=o,t[1]=e,t[2]=-e,t[3]=o,t}function y(){var t=new m(6);return m!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0),t[0]=1,t[3]=1,t}function x(t,n){var e=Math.sin(n),o=Math.cos(n);return t[0]=o,t[1]=e,t[2]=-e,t[3]=o,t[4]=0,t[5]=0,t}Math.hypot||(Math.hypot=function(){for(var t=0,n=arguments.length;n--;)t+=arguments[n]*arguments[n];return Math.sqrt(t)});var w=function(t,n,e){var o=n[0],r=n[1],s=n[2],i=n[3],a=n[4],c=n[5],u=e[0],f=e[1],d=e[2],l=e[3],g=e[4],h=e[5];return t[0]=o*u+s*f,t[1]=r*u+i*f,t[2]=o*d+s*l,t[3]=r*d+i*l,t[4]=o*g+s*h+a,t[5]=r*g+i*h+c,t};function k(t,n,e){return t[0]=n,t[1]=e,t}function E(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t}function v(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t}function B(t,n,e,o){var r=n[0],s=n[1];return t[0]=r+o*(e[0]-r),t[1]=s+o*(e[1]-s),t}function P(t,n,e){var o=n[0],r=n[1];return t[0]=e[0]*o+e[2]*r,t[1]=e[1]*o+e[3]*r,t}function F(t,n,e){var o=n[0],r=n[1];return t[0]=e[0]*o+e[2]*r+e[4],t[1]=e[1]*o+e[3]*r+e[5],t}var L,C=function(t){var n=t[0],e=t[1];return Math.hypot(n,e)},V=function(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t};L=new m(2),m!=Float32Array&&(L[0]=0,L[1]=0);const I=2*Math.PI;function A(t,n,e){return t+(n-t)*e}function S(t){return t/180*Math.PI}function Q(t,n){const e=Math.sign(t[0]*n[1]-t[1]*n[0]);return 0===e&&Math.abs(t[0]+n[0])<1e-12&&Math.abs(t[1]+n[1])<1e-12?Math.PI:e*Math.acos((r=n,((o=t)[0]*r[0]+o[1]*r[1])/C(t)/C(n)));var o,r}function T(t,n,e=0){return Math.abs(t[0]-n[0])<=e&&Math.abs(t[1]-n[1])<=e}function O(t){return t[1]}function N(t){switch(t[0]){case"L":return t[2];case"C":return t[4];case"Q":return t[3];case"A":return t[7]}}function q(t){switch(t[0]){case"L":return["L",t[2],t[1]];case"C":return["C",t[4],t[3],t[2],t[1]];case"Q":return["Q",t[3],t[2],t[1]];case"A":return["A",t[7],t[2],t[3],t[4],t[5],!t[6],t[1]]}}const D=(()=>{const t=[0,0],n=b(),e=[0,0],o=[0,0];return function([r,s,i,a,c,u,f,d]){if(0===i||0===a)return null;M(n,-S(c)),V(t,s,d),v(t,t,.5),P(t,t,n);let l=i*i,g=a*a;const h=t[0]*t[0],p=t[1]*t[1];i=Math.abs(i),a=Math.abs(a);const m=h/l+p/g+1e-12;if(m>1){const t=Math.sqrt(m);i*=t,a*=t;const n=Math.abs(m);l*=n,g*=n}const b=u===f?-1:1,y=Math.sqrt((l*g-l*p-g*h)/(l*p+g*h)),x=b*y*(i*t[1]/a),w=b*y*(-a*t[0]/i);!function(t,n){if(t===n){var e=n[1];t[1]=n[2],t[2]=e}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3]}(n,n),E(e,s,d),v(e,e,.5),P(o,[x,w],n),E(o,o,e);const k=[(t[0]-x)/i,(t[1]-w)/a],B=Q([1,0],k);let F=Q(k,[(-t[0]-x)/i,(-t[1]-w)/a]);return!f&&F>0?F-=I:f&&F<0&&(F+=I),{center:[o[0],o[1]],theta1:B,deltaTheta:F,rx:i,ry:a,phi:c}}})(),W=(()=>{const t=[0,0],n=[0,0],e=b();return function({center:o,theta1:r,deltaTheta:s,rx:i,ry:a,phi:c}){M(e,c),k(t,i*Math.cos(r),a*Math.sin(r)),P(t,t,e),E(t,t,o),k(n,i*Math.cos(r+s),a*Math.sin(r+s)),P(n,n,e),E(n,n,o);const u=Math.abs(s)>Math.PI;return["A",[t[0],t[1]],i,a,c,u,s>0,[n[0],n[1]]]}})(),Z=(()=>{const t=[0,0],n=[0,0],e=[0,0],o=[0,0],r=[0,0],s=[0,0];return function(i,a){switch(i[0]){case"L":B(s,i[1],i[2],a);break;case"C":B(t,i[1],i[2],a),B(n,i[2],i[3],a),B(e,i[3],i[4],a),B(o,t,n,a),B(r,n,e,a),B(s,o,r,a);break;case"Q":B(t,i[1],i[2],a),B(n,i[2],i[3],a),B(s,t,n,a);break;case"A":{const t=D(i);if(!t){B(s,i[1],i[7],a);break}const{deltaTheta:n,phi:e,theta1:o,rx:r,ry:c,center:u}=t,f=o+a*n;k(s,r*Math.cos(f),c*Math.sin(f)),function(t,n,e,o){var r=n[0]-e[0],s=n[1]-e[1],i=Math.sin(o),a=Math.cos(o);t[0]=r*a-s*i+e[0],t[1]=r*i+s*a+e[1]}(s,s,[0,0],e),E(s,s,u);break}}return[s[0],s[1]]}})(),$=(()=>{const t=y(),n=y();return function(e,o=Math.PI/2){const r=D(e);if(!r)return[["L",e[1],e[7]]];const{center:s,theta1:i,deltaTheta:a,rx:c,ry:u}=r,f=Math.ceil(Math.abs(a)/o);!function(t,n){t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1]}(t,s),function(t,n,e){var o=n[0],r=n[1],s=n[2],i=n[3],a=n[4],c=n[5],u=Math.sin(e),f=Math.cos(e);t[0]=o*f+s*u,t[1]=r*f+i*u,t[2]=o*-u+s*f,t[3]=r*-u+i*f,t[4]=a,t[5]=c}(t,t,S(e[4])),function(t,n,e){var o=n[0],r=n[1],s=n[2],i=n[3],a=n[4],c=n[5],u=e[0],f=e[1];t[0]=o*u,t[1]=r*u,t[2]=s*f,t[3]=i*f,t[4]=a,t[5]=c}(t,t,[c,u]);const d=[],l=a/f,g=4/3*Math.tan(l/4),h=Math.sin(l),p=Math.cos(l);for(let e=0;e<f;e++){const o=[1,0],r=[1,g],s=[p+g*h,h-g*p],a=[p,h];x(n,i+e*l),w(n,t,n),F(o,o,n),F(r,r,n),F(s,s,n),F(a,a,n),d.push(["C",o,r,s,a])}return d}})();function j(t,n,e,o,r){const s=A(t,n,r),i=A(n,e,r),a=A(e,o,r),c=A(s,i,r),u=A(i,a,r);return A(c,u,r)}function z(t,n,e,o){let r=Math.min(t,o),s=Math.max(t,o);const i=3*(3*n-t-3*e+o),a=6*(t-2*n+e),c=a*a-4*i*(3*(n-t));if(c<0||0===i)return[r,s];const u=Math.sqrt(c),f=(-a-u)/(2*i);if(0<f&&f<1){const i=j(t,n,e,o,f);r=Math.min(r,i),s=Math.max(s,i)}const d=(-a+u)/(2*i);if(0<d&&d<1){const i=j(t,n,e,o,d);r=Math.min(r,i),s=Math.max(s,i)}return[r,s]}function R(t,n,e){let o=Math.min(t,e),r=Math.max(t,e);const s=t-2*n+e;if(0===s)return[o,r];const i=(t-n)/s;if(0<=i&&i<=1){const s=function(t,n,e,o){const r=A(t,n,o),s=A(n,e,o);return A(r,s,o)}(t,n,e,i);o=Math.min(o,s),r=Math.max(r,s)}return[o,r]}function H(t,n,e){const o=(t-n)/(e-n);return 0<=o&&o<=1}function U(t){switch(t[0]){case"L":return{top:Math.min(t[1][1],t[2][1]),right:Math.max(t[1][0],t[2][0]),bottom:Math.max(t[1][1],t[2][1]),left:Math.min(t[1][0],t[2][0])};case"C":{const[n,e]=z(t[1][0],t[2][0],t[3][0],t[4][0]),[o,r]=z(t[1][1],t[2][1],t[3][1],t[4][1]);return{top:o,right:e,bottom:r,left:n}}case"Q":{const[n,e]=R(t[1][0],t[2][0],t[3][0]),[o,r]=R(t[1][1],t[2][1],t[3][1]);return{top:o,right:e,bottom:r,left:n}}case"A":{const n=D(t);if(!n)return f(l(t[1],0),t[7]);const{theta1:e,deltaTheta:o,phi:r,center:s,rx:i,ry:a}=n;if(0===r||i===a){const n=e+o;let r=f(l(t[1],0),t[7]);return(H(-Math.PI,e,n)||H(Math.PI,e,n))&&(r=f(r,[s[0]-i,s[1]])),(H(-Math.PI/2,e,n)||H(3*Math.PI/2,e,n))&&(r=f(r,[s[0],s[1]-a])),(H(0,e,n)||H(2*Math.PI,e,n))&&(r=f(r,[s[0]+i,s[1]])),(H(Math.PI/2,e,n)||H(5*Math.PI/2,e,n))&&(r=f(r,[s[0],s[1]+a])),function(t,n){return{top:t.top-n,right:t.right+n,bottom:t.bottom+n,left:t.left-n}}(r,1e-11)}const c=$(t,Math.PI/16);let d=null;for(const t of c)d=u(d,U(t));return d||l(t[1],0)}}}function G(t,n){const e=t[1],o=t[2],r=B([0,0],e,o,n);return[["L",e,r],["L",r,o]]}function _(t,n){const e=t[1],o=t[2],r=t[3],s=t[4],i=B([0,0],e,o,n),a=B([0,0],o,r,n),c=B([0,0],r,s,n),u=B([0,0],i,a,n),f=B([0,0],a,c,n),d=B([0,0],u,f,n);return[["C",e,i,u,d],["C",d,f,c,s]]}function J(t,n){switch(t[0]){case"L":return G(t,n);case"C":return _(t,n);case"Q":return function(t,n){const e=t[1],o=t[2],r=t[3],s=B([0,0],e,o,n),i=B([0,0],o,r,n),a=B([0,0],s,i,n);return[["Q",e,s,a],["Q",a,i,r]]}(t,n);case"A":return function(t,n){const e=D(t);if(!e)return G(["L",t[1],t[7]],n);const o=e.deltaTheta*n;return[W({...e,deltaTheta:o}),W({...e,theta1:e.theta1+o,deltaTheta:e.deltaTheta-o})]}(t,n)}}const K=64*Number.MIN_VALUE;function X([[t,n],[e,o]],[[r,s],[i,a]],c){const u=e-t,f=r-i,d=r-t,l=o-n,g=s-a,h=s-n,p=u*g-l*f;if(Math.abs(p)<K)return null;const m=(d*g-h*f)/p,b=(u*h-l*d)/p;return-c<=m&&m<=1+c&&-c<=b&&b<=1+c?[m,b]:null}function Y(t){const[n,e]=J(t.seg,.5),o=(t.startParam+t.endParam)/2;return[{seg:n,startParam:t.startParam,endParam:o,boundingBox:U(n)},{seg:e,startParam:o,endParam:t.endParam,boundingBox:U(e)}]}function tt(t){switch(t[0]){case"L":return[t[1],t[2]];case"C":return[t[1],t[4]];case"Q":return[t[1],t[3]];case"A":return[t[1],t[7]]}}function nt({seg:t,boundingBox:n},{seg:e,boundingBox:o}){return"L"===t[0]?"L"===e[0]?function(t,n,e){return!!X(t,n,e)}([t[1],t[2]],[e[1],e[2]],1e-6):a([t[1],t[2]],o):"L"===e[0]?a([e[1],e[2]],n):c(n,o)}function et(t,n,e){const o=t[0];if(n[0]!==o)return!1;switch(o){case"L":return T(t[1],n[1],e)&&T(t[2],n[2],e);case"C":return T(t[1],n[1],e)&&T(t[2],n[2],e)&&T(t[3],n[3],e)&&T(t[4],n[4],e);case"Q":return T(t[1],n[1],e)&&T(t[2],n[2],e)&&T(t[3],n[3],e);case"A":return T(t[1],n[1],e)&&Math.abs(t[2]-n[2])<e&&Math.abs(t[3]-n[3])<e&&Math.abs(t[4]-n[4])<e&&t[5]===n[5]&&t[6]===n[6]&&T(t[7],n[7],e)}}function ot(t,n,e,o){if("L"===t[0]&&"L"===n[0]){const r=X([t[1],t[2]],[n[1],n[2]],o.param);if(r)return!e&&(r[0]<o.param||r[0]>1-o.param)&&(r[1]<o.param||r[1]>1-o.param)?[]:[r]}let r=[[{seg:t,startParam:0,endParam:1,boundingBox:U(t)},{seg:n,startParam:0,endParam:1,boundingBox:U(n)}]];const s=[];for(;r.length;){const t=[];for(const[n,e]of r){if(et(n.seg,e.seg,o.point))continue;const r=d(n.boundingBox)<=o.linear,i=d(e.boundingBox)<=o.linear;if(r&&i){const t=X(tt(n.seg),tt(e.seg),o.param);t&&s.push([A(n.startParam,n.endParam,t[0]),A(e.startParam,e.endParam,t[1])])}else{const o=r?[n]:Y(n),s=i?[e]:Y(e);for(const n of o)for(const e of s)nt(n,e)&&t.push([n,e])}}r=t}return e?s:s.filter((([t,n])=>t>o.param&&t<1-o.param||n>o.param&&n<1-o.param))}const rt=Object.hasOwn;function st(t){const n=new WeakMap;return(e,...o)=>{if(n.has(e))return n.get(e);{const r=t(e,...o);return n.set(e,r),r}}}function*it(t,n){let e=0;for(const o of t)yield n(o,e++)}const at=8,ct=8,ut={point:1e-6,linear:1e-4,param:1e-8};var ft,dt;function lt(){let t=0;return st((()=>t++))}function gt(t){return n=>({seg:n,parent:t})}function ht(t){return t.outgoingEdges.length}function pt({directionFlag:t,segments:n}){let e,o;const r=n[0];return t?(e=Z(r,1),o=Z(r,1-ut.param)):(e=Z(r,0),o=Z(r,ut.param)),Math.atan2(o[1]-e[1],o[0]-e[0])}function mt(t){const{outgoingEdges:n}=t.incidentVertices[1],e=n.findIndex((n=>n.twin===t));return n[(e+1)%n.length]}t.PathBooleanOperation=void 0,(ft=t.PathBooleanOperation||(t.PathBooleanOperation={}))[ft.Union=0]="Union",ft[ft.Difference=1]="Difference",ft[ft.Intersection=2]="Intersection",ft[ft.Exclusion=3]="Exclusion",ft[ft.Division=4]="Division",ft[ft.Fracture=5]="Fracture",t.FillRule=void 0,(dt=t.FillRule||(t.FillRule={}))[dt.NonZero=0]="NonZero",dt[dt.EvenOdd=1]="EvenOdd";const bt=st((t=>t.incidentEdges.flatMap((t=>{const n=[];for(const e of t.segments)for(let o=0;o<64;o++){const r=o/64,s=t.directionFlag?1-r:r;n.push(Z(e,s))}return n}))));function Mt(t,n,e){return t>=e==n<e}function yt(t,n,e){return!!Mt(t[1],n[1],e[1])&&(o=e[1],r=t[1],s=n[1],i=t[0],a=n[0],(o-r)/(s-r)*(a-i)+i>=e[0]);var o,r,s,i,a}function xt(t,n){if(t.length<=2)return 0;let e=t[t.length-1],o=0;for(const r of t)yt(e,r,n)&&(o+=r[1]>e[1]?-1:1),e=r;return o}function wt(t){const n=bt(t);for(let t=0;t<n.length;t++){const e=n[t],o=n[(t+1)%n.length],r=n[(t+2)%n.length],s=[(e[0]+o[0]+r[0])/3,(e[1]+o[1]+r[1])/3],i=xt(n,s);if(0!==i)return{winding:i,point:s}}}function kt(t,n){return Mt(t.top,t.bottom,n[1])&&t.right>=n[0]}function Et(t,n){const e=U(t);if(!kt(e,n))return 0;let o=[{boundingBox:e,seg:t}],r=0;for(;o.length>0;){const t=[];for(const{boundingBox:e,seg:s}of o)if(d(e)<ut.linear)yt(O(s),N(s),n)&&r++;else{const e=J(s,.5),o=U(e[0]);kt(o,n)&&t.push({boundingBox:o,seg:e[0]});const r=U(e[1]);kt(r,n)&&t.push({boundingBox:r,seg:e[1]})}o=t}return r}function vt(t,n){const e=O(t.edges[0].segments[0]);for(const t of n.vertices){if(t===n.outerFace)continue;let o=0;for(const n of t.incidentEdges)for(const t of n.segments)o+=Et(t,e);if(o%2==1)return t}return null}function Bt(n,e){switch(e){case t.FillRule.NonZero:return 0===n?0:1;case t.FillRule.EvenOdd:return n%2==0?0:1}}function*Pt(t){function n(n){return t.has(n.incidentVertex)===t.has(n.twin.incidentVertex)}const e=new WeakMap;for(const n of t){let t=n.incidentEdges[n.incidentEdges.length-1];for(const o of n.incidentEdges)e.set(t,o),t=o}const o=new WeakSet;for(const r of t)for(const t of r.incidentEdges){if(n(t)||o.has(t))continue;let r=t;do{for(r.directionFlag?yield*it(r.segments,q):yield*r.segments,o.add(r),r=e.get(r);n(r);)r=e.get(r.twin)}while(r!==t)}}const Ft={[t.PathBooleanOperation.Union]:({flag:t})=>t>0,[t.PathBooleanOperation.Difference]:({flag:t})=>1===t,[t.PathBooleanOperation.Intersection]:({flag:t})=>3===t,[t.PathBooleanOperation.Exclusion]:({flag:t})=>1===t||2===t,[t.PathBooleanOperation.Division]:({flag:t})=>!(1&~t),[t.PathBooleanOperation.Fracture]:({flag:t})=>t>0};function Lt(t,n){return[2*t[0]-n[0],2*t[1]-n[1]]}function*Ct(t){let n=null,e=null,o=null;function r(){throw new Error("Bad SVG path data sequence.")}for(const s of function*(t){let n=[0,0],e=n;for(const o of t)switch(o[0]){case"M":yield o,n=e=o[1];break;case"L":case"T":yield o,n=o[1];break;case"C":yield o,n=o[3];break;case"S":case"Q":yield o,n=o[2];break;case"A":yield o,n=o[6];break;case"Z":case"z":n=e,yield["Z"];break;case"H":n=[o[1],n[1]],yield["L",n];break;case"V":n=[n[0],o[1]],yield["L",n];break;case"m":n=e=[n[0]+o[1],n[1]+o[2]],yield["M",n];break;case"l":n=[n[0]+o[1],n[1]+o[2]],yield["L",n];break;case"h":n=[n[0]+o[1],n[1]],yield["L",n];break;case"v":n=[n[0],n[1]+o[1]],yield["L",n];break;case"c":yield["C",[n[0]+o[1],n[1]+o[2]],[n[0]+o[3],n[1]+o[4]],n=[n[0]+o[5],n[1]+o[6]]];break;case"s":yield["S",[n[0]+o[1],n[1]+o[2]],n=[n[0]+o[3],n[1]+o[4]]];break;case"q":yield["Q",[n[0]+o[1],n[1]+o[2]],n=[n[0]+o[3],n[1]+o[4]]];break;case"t":yield["T",n=[n[0]+o[1],n[1]+o[2]]];break;case"a":yield["A",o[1],o[2],o[3],o[4],o[5],n=[n[0]+o[6],n[1]+o[7]]]}}(t))switch(s[0]){case"M":e=n=s[1],o=null;break;case"L":e||r(),yield["L",e,s[1]],e=s[1],o=null;break;case"C":e||r(),yield["C",e,s[1],s[2],s[3]],e=s[3],o=s[2];break;case"S":e||r(),o||r(),yield["C",e,Lt(e,o),s[1],s[2]],e=s[2],o=s[1];break;case"Q":e||r(),yield["Q",e,s[1],s[2]],e=s[2],o=s[1];break;case"T":e||r(),o||r(),o=Lt(e,o),yield["Q",e,o,s[1]],e=s[1];break;case"A":e||r(),yield["A",e,s[1],s[2],s[3],s[4],s[5],s[6]],e=s[6],o=null;break;case"Z":case"z":e||r(),n||r(),yield["L",e,n],e=n,o=null}}function*Vt(t,n=1e-4){let e=null;for(const o of t)switch(e&&T(o[1],e,n)||(yield["M",o[1]]),o[0]){case"L":yield["L",e=o[2]];break;case"C":yield["C",o[2],o[3],e=o[4]];break;case"Q":yield["Q",o[2],e=o[3]];break;case"A":yield["A",o[2],o[3],o[4],o[5],o[6],e=o[7]]}}const It=Symbol();function*At(t){const n=/\s*,?\s*(-?\d*(?:\d\.|\.\d|\d)\d*(?:[eE][+\-]?\d+)?)/y,e=/\s*([MLCSQTAZHVmlhvcsqtaz])/y,o=/\s*,?\s*([01])/y;let r=0,s="M";function i(){if(r>=t.length-1)return It;e.lastIndex=r;const n=e.exec(t);if(!n)switch(s){case"M":return"L";case"m":return"l";default:return s}return r=e.lastIndex,n[1]}function a(){n.lastIndex=r;const e=n.exec(t);if(!e)throw new Error(`Invalid path data. Expected a number at index ${r}.`);return r=n.lastIndex,Number(e[1])}function c(){o.lastIndex=r;const n=o.exec(t);if(!n)throw new Error(`Invalid path data. Expected a flag at index ${r}.`);return r=o.lastIndex,"1"===n[1]}for(;;)switch(i()){case"M":yield[s="M",[a(),a()]];break;case"L":yield[s="L",[a(),a()]];break;case"C":yield[s="C",[a(),a()],[a(),a()],[a(),a()]];break;case"S":yield[s="S",[a(),a()],[a(),a()]];break;case"Q":yield[s="Q",[a(),a()],[a(),a()]];break;case"T":yield[s="T",[a(),a()]];break;case"A":yield[s="A",a(),a(),a(),c(),c(),[a(),a()]];break;case"Z":case"z":yield[s="Z"];break;case"H":yield[s="H",a()];break;case"V":yield[s="V",a()];break;case"m":yield[s="m",a(),a()];break;case"l":yield[s="l",a(),a()];break;case"h":yield[s="h",a()];break;case"v":yield[s="v",a()];break;case"c":yield[s="c",a(),a(),a(),a(),a(),a()];break;case"s":yield[s="s",a(),a(),a(),a()];break;case"q":yield[s="q",a(),a(),a(),a()];break;case"t":yield[s="t",a(),a()];break;case"a":yield[s="a",a(),a(),a(),c(),c(),a(),a()];break;case It:return}}t.arcSegmentToCubics=$,t.commandsFromPathData=At,t.pathBoolean=function(n,e,o,r,s){const i=[...it(n,gt(1)),...it(o,gt(2))];!function(t){for(let n=0;n<t.length;n++){const e=t[n];if("C"!==e.seg[0])continue;const o=p(e.seg);if(!o)continue;o[0]>o[1]&&o.reverse();const[r,s]=o;if(Math.abs(r-s)<ut.param){const[o,s]=_(e.seg,r);t[n]={seg:o,parent:e.parent},t.push({seg:s,parent:e.parent})}else{const[o,i]=_(e.seg,r),[a,c]=_(i,(s-r)/(1-r));t[n]={seg:o,parent:e.parent},t.push({seg:a,parent:e.parent},{seg:c,parent:e.parent})}}}(i);const{edges:a,totalBoundingBox:c}=function(t){const n=t.map((t=>({...t,boundingBox:U(t.seg)}))),e=n.reduce(((t,{boundingBox:n})=>u(t,n)),null);if(!e)return{edges:[],totalBoundingBox:null};const o=new g(e,at),r={};function s(t,n){rt(r,t)||(r[t]=[]),r[t].push(n)}for(let e=0;e<n.length;e++){const r=n[e],i=o.find(r.boundingBox);for(const n of i){const o=t[n],i=r.parent!==o.parent||!(T(N(o.seg),O(r.seg),ut.point)||T(O(o.seg),N(r.seg),ut.point)),a=ot(r.seg,o.seg,i,ut);for(const[t,o]of a)s(e,t),s(n,o)}o.insert(r.boundingBox,e)}const i=[];for(let t=0;t<n.length;t++){const e=n[t];if(!rt(r,t)){i.push(e);continue}const o=r[t];o.sort();let s=e.seg,a=0;for(let t=0;t<o.length;t++){const n=o[t];if(n>1-ut.param)break;const r=(n-a)/(1-a);if(a=n,r<ut.param)continue;if(r>1-ut.param)continue;const[c,u]=J(s,r);i.push({seg:c,boundingBox:U(c),parent:e.parent}),s=u}i.push({seg:s,boundingBox:U(s),parent:e.parent})}return{edges:i,totalBoundingBox:e}}(i);if(!c)return[];const f=function(t,n){const e=new g(n,ct),o=[];function r(t){const n=l(t,ut.point),r=e.find(n);if(r.size)return function(t){return t.values().next().value}(r);{const r={point:t,outgoingEdges:[]};return e.insert(n,r),o.push(r),r}}const s=lt(),i={};return{edges:t.flatMap((t=>{const n=r(O(t.seg)),e=r(N(t.seg));if(n===e)switch(t.seg[0]){case"L":return[];case"C":if(T(t.seg[1],t.seg[2],ut.point)&&T(t.seg[3],t.seg[4],ut.point))return[];break;case"Q":if(T(t.seg[1],t.seg[2],ut.point))return[];break;case"A":if(!1===t.seg[5])return[]}const o=`${s(n)}:${s(e)}`;if(rt(i,o)){const n=i[o].find((n=>et(n[0].seg,t.seg,ut.point)));if(n)return n[1].parent|=t.parent,n[2].parent|=t.parent,[]}const a={...t,incidentVertices:[n,e],directionFlag:!1,twin:null},c={...t,incidentVertices:[e,n],directionFlag:!0,twin:a};return a.twin=c,n.outgoingEdges.push(a),e.outgoingEdges.push(c),rt(i,o)?i[o].push([t,a,c]):i[o]=[[t,a,c]],[a,c]})),vertices:o}}(a,c),d=function({vertices:t}){const n=[],e=[],o=st((t=>{const n={outgoingEdges:[]};return e.push(n),n})),r=lt(),s={},i=new WeakSet;for(const e of t){if(2===ht(e))continue;const t=o(e);for(const a of e.outgoingEdges){const e=[];let c=a;for(;c.parent===a.parent&&c.directionFlag===a.directionFlag&&2===ht(c.incidentVertices[1]);){e.push(c.seg),i.add(c.incidentVertices[1]);const[t,n]=c.incidentVertices[1].outgoingEdges;c=t.twin===c?n:t}e.push(c.seg);const u=o(c.incidentVertices[1]),f=`${r(a)}-${r(c)}`,d=s[`${r(c.twin)}-${r(a.twin)}`]??null,l={segments:e,parent:a.parent,incidentVertices:[t,u],directionFlag:a.directionFlag,twin:d};d&&(d.twin=l),s[f]=l,t.outgoingEdges.push(l),n.push(l)}}const a=[];for(const n of t){if(2!==ht(n)||i.has(n))continue;let t=n.outgoingEdges[0];const e={segments:[],parent:t.parent,directionFlag:t.directionFlag};do{e.segments.push(t.seg),i.add(t.incidentVertices[0]);const[n,o]=t.incidentVertices[1].outgoingEdges;t=n.twin===t?o:n}while(t.incidentVertices[0]!==n);a.push(e)}return{edges:n,vertices:e,cycles:a}}(f);!function(t){function n(n){const e=new WeakSet,o=new WeakMap;function r(t,s,i){if(o.has(t))return o.get(t);o.set(t,i);let a=1/0;for(const e of t.outgoingEdges)e.parent&n&&e!==s&&(a=Math.min(a,r(e.incidentVertices[1],e.twin,i+1)));return a<=i&&e.add(t),a}for(const e of t.edges)e.parent&n&&r(e.incidentVertices[0],null,0);return e}const e=n(1),o=n(2);function r(t){return!(1&~t.parent)&&e.has(t.incidentVertices[0])&&e.has(t.incidentVertices[1])||!(2&~t.parent)&&o.has(t.incidentVertices[0])&&o.has(t.incidentVertices[1])}t.vertices=t.vertices.filter((function(t){return e.has(t)||o.has(t)}));for(const n of t.vertices)n.outgoingEdges=n.outgoingEdges.filter(r);t.edges=t.edges.filter(r)}(d),function({vertices:t}){const n=st(pt);for(const e of t)ht(e)>2&&e.outgoingEdges.sort(((t,e)=>n(t)-n(e)))}(d);const h=function(t){let n=[];function e(t,n){let o=!1;for(const r of t){const t=vt(n,r.component);if(t){if(r.outgoingEdges.has(t)){const o=r.outgoingEdges.get(t);r.outgoingEdges.set(t,e(o,n))}else r.outgoingEdges.set(t,[{component:n,outgoingEdges:new Map}]);o=!0;break}}if(o)return t;{const e={component:n,outgoingEdges:new Map},o=[e];for(const r of t){const t=vt(r.component,n);t?e.outgoingEdges.has(t)?e.outgoingEdges.get(t).push(r):e.outgoingEdges.set(t,[r]):o.push(r)}return o}}for(const o of t)n=e(n,o);return n}(function({edges:t,cycles:n}){const e=[],o=new WeakMap;for(const n of t){if(o.has(n))continue;const t={incidentEdges:[],flag:0};let r=n;do{const n=o.get(r.twin)??null,e={segments:r.segments,parent:r.parent,incidentVertex:t,directionFlag:r.directionFlag,twin:n};n&&(n.twin=e),o.set(r,e),t.incidentEdges.push(e),r=mt(r)}while(r.incidentVertices[0]!==n.incidentVertices[0]);e.push(t)}for(const t of n){const n={incidentEdges:[],flag:0},o={segments:t.segments,parent:t.parent,incidentVertex:n,directionFlag:t.directionFlag,twin:null},r={incidentEdges:[],flag:0},s={segments:[...t.segments].reverse(),parent:t.parent,incidentVertex:r,directionFlag:!t.directionFlag,twin:o};o.twin=s,n.incidentEdges.push(o),r.incidentEdges.push(s),e.push(n,r)}const r=[],s=new WeakSet,i=new WeakSet;for(const t of e){if(s.has(t))continue;const n=[],e=[],o=t=>{s.has(t)||n.push(t),s.add(t);for(const n of t.incidentEdges){if(i.has(n))continue;const{twin:t}=n;e.push(n,t),i.add(n),i.add(t),o(t.incidentVertex)}};o(t);const a=n.find((t=>wt(t).winding<0));r.push({vertices:n,edges:e,outerFace:a})}return r}(d));!function(t,n,e){function o(t,r,s){const i=new WeakSet;!function r(s,a,c){if(i.has(s))return;i.add(s);const u=Bt(a,n),f=Bt(c,e);s.flag=u|f<<1;for(const t of s.incidentEdges){const n=t.twin;let e=a;1&t.parent&&(e+=t.directionFlag?-1:1);let o=c;2&t.parent&&(o+=t.directionFlag?-1:1),r(n.incidentVertex,e,o)}if(t.outgoingEdges.has(s)){const n=t.outgoingEdges.get(s);for(const t of n)o(t,a,c)}}(t.component.outerFace,r,s)}for(const n of t)o(n,0,0)}(h,e,r);const m=Ft[s];switch(s){case t.PathBooleanOperation.Division:case t.PathBooleanOperation.Fracture:return function(t,n){const e=[];function o(t){for(const o of t.component.vertices){if(!n(o)||o===t.component.outerFace)continue;const r=[];for(const t of o.incidentEdges)t.directionFlag?r.push(...t.segments.map(q)):r.push(...t.segments);if(t.outgoingEdges.has(o))for(const n of t.outgoingEdges.get(o)){const{outerFace:t}=n.component;for(const n of t.incidentEdges)n.directionFlag?r.push(...n.segments.map(q)):r.push(...n.segments)}e.push(r)}for(const n of t.outgoingEdges.values())for(const t of n)o(t)}for(const n of t)o(n);return e}(h,m);default:{const t=new Set(function*(t,n){function*e(t){for(const e of t.component.vertices)n(e)&&(yield e);for(const n of t.outgoingEdges.values())for(const t of n)yield*e(t)}for(const n of t)yield*e(n)}(h,m));return[[...Pt(t)]]}}},t.pathCubicSegmentSelfIntersection=p,t.pathFromCommands=Ct,t.pathFromPathData=function(t){return[...Ct(At(t))]},t.pathSegmentBoundingBox=U,t.pathSegmentIntersection=ot,t.pathToCommands=Vt,t.pathToPathData=function(t,n=1e-4){function e(t){return"string"==typeof t?t:function(t){return"number"==typeof t}(t)?t.toFixed(12):function(t){return"boolean"==typeof t}(t)?t?"1":"0":t.map((t=>t.toFixed(12))).join(",")}return[...it(Vt(t,n),(t=>t.map(e).join(" ")))].join(" ")},t.samplePathSegmentAt=Z},"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).PathBool={});
//# sourceMappingURL=path-bool.umd.js.map
